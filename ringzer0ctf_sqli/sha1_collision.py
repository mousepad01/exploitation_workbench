from hashlib import sha1
from multiprocessing import Process
import random

MLEN = 10

def find_collision(collision=b"'OR'1"):

    CL = len(collision)

    c = [chr(i).encode() for i in range(ord('a'), ord('z') + 1)] + \
            [chr(i).encode() for i in range(ord('0'), ord('9') + 1)]

    L = len(c)

    while True:

        s = b''.join([c[random.randint(0, L - 1)] for _ in range(MLEN)])
        
        if sha1(s).digest()[:CL] == collision:
            print(f"found: string {s}, SHA-1 digest {sha1(s).digest()}")

            # multithr unsafe?
            with open("collisions.bin", "ab") as f:
                f.write(s)
                f.flush()

def check():

    with open("collisions.bin", "rb") as f:
        s_ = f.read()

    for i in range(len(s_) // MLEN):
        s = s_[MLEN * i: MLEN * (i + 1)]

        print(f"string {s}, SHA-1 digest {sha1(s).digest()}")


def search(P, collision=b"'OR'1"):

    for _ in range(P - 1):

        p = Process(target=find_collision, args=(collision,))
        p.daemon = True
        p.start()

    find_collision(collision)

if __name__ == "__main__":
    search(8, b"'OR'")
    #check()