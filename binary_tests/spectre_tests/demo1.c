#include <stdio.h>
#include <stdlib.h>
#include <x86intrin.h>
#include <unistd.h>
#include <fcntl.h>

#define V_STEPS 256
#define V_DIST (512)
#define V_LEN (V_DIST * V_STEPS)

#define TEST_CNT 10000

#define CACHE_HIT_THRESH 80

#define CHOICE 146
#define ALTCHOICE 200

char accessed[V_LEN];

u_int64_t results[V_STEPS];
int var[4096]; // avoid page(var) == page(accessed[first slice])

void f(size_t x)
{
    var[0] = accessed[x * V_DIST];
}

void save_stats()
{   

    int fd = open("e1_stats.bin", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXG | S_IRWXU | S_IRWXO);

    u_int64_t test_cnt = TEST_CNT;

    write(fd, (char *)(&test_cnt), 8);
    write(fd, results, V_STEPS * sizeof(u_int64_t));

    close(fd);
}

void execute_access()
{   

    for(int t = 0; t < TEST_CNT; t++){

        /* prepare */

        for(int i = 0; i < V_STEPS; i++)
            _mm_clflush(accessed + i * V_DIST);

        /* execute */

        f(CHOICE);
        
        for(volatile delay = 0; delay < 10000; delay++) {}
    }
}

void check_access()
{   
    volatile char *addr;
    int j;
    register u_int64_t tstart, tend;

    u_int64_t ignored;

    for(int t = 0; t < TEST_CNT; t++){

        /* check */

        for(int i = 0; i < V_STEPS; i++){

            j = ((i * 167) + 13) & (V_STEPS - 1);
            addr = accessed + j * V_DIST;

            tstart = __rdtscp(&ignored);
            ignored = *addr;
            tend = __rdtscp(&ignored);

            if(tend - tstart < CACHE_HIT_THRESH)
                results[j] += 1;
        }

        for(volatile delay = 0; delay < 100; delay++) {}
    }

    save_stats();
}

int main()
{   
    for (int i = 0; i < V_STEPS; i++)
        accessed[i * V_DIST] = i;

    int pid = fork();
    if(pid == 0){

        execute_access();
    }
    else{

        check_access();
    }
    
    return 0;
}